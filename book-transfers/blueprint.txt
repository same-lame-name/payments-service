<<--FILE_START-->>
Path: ./app/pom.xml
<<--CONTENT_START-->>
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>dexter.demo.payment</groupId>
        <artifactId>book-transfers-service</artifactId>
        <version>0.1.0-SNAPSHOT</version>
    </parent>

    <artifactId>book-transfers-app</artifactId>
    <name>Book Transfers :: App</name>
    <description>The runnable application module (Composition Root).</description>

    <dependencies>
        <dependency>
            <groupId>dexter.demo.payment</groupId>
            <artifactId>book-transfers-infrastructure</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-tracing-bridge-brave</artifactId>
        </dependency>
        <dependency>
            <groupId>io.zipkin.reporter2</groupId>
            <artifactId>zipkin-reporter-brave</artifactId>
        </dependency>
        <dependency>
            <groupId>net.logstash.logback</groupId>
            <artifactId>logstash-logback-encoder</artifactId>
            <version>${logstash-logback-encoder.version}</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- This activates the spring-boot-maven-plugin for this module -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <!-- Overriding the main class to point to the correct location in this module -->
                    <mainClass>dexter.banking.booktransfers.infrastructure.BookTransfersApplication</mainClass>
                    <layout>JAR</layout>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <!-- This module also opts-in to the Docker build -->
            <plugin>
                <groupId>io.fabric8</groupId>
                <artifactId>docker-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
<<--FILE_END-->>
<<--FILE_START-->>
Path: ./app/src/main/java/dexter/banking/booktransfers/app/BookTransfersApplication.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.app;

import dexter.banking.booktransfers.infrastructure.FacadeConfiguration;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.ComponentScans;
import org.springframework.context.annotation.FilterType;

/**
 * The main entry point for the Book Transfers application.
 *
 * @SpringBootApplication enables auto-configuration but its default component scan is disabled.
 * We use @ComponentScans to define two precise rules:
 * 1. A standard scan for all components within the 'core' and 'app' modules.
 * 2. A custom, filtered scan for the 'infrastructure' module that ONLY discovers beans
 * that implement the FacadeConfiguration marker interface. This is enforced by
 * useDefaultFilters = false.
 */
@SpringBootApplication
@ComponentScans({
    @ComponentScan(basePackages = {"dexter.banking.booktransfers.core", "dexter.banking.booktransfers.app"}),
    @ComponentScan(
        basePackages = "dexter.banking.booktransfers.infrastructure",
        includeFilters = @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = FacadeConfiguration.class),
        useDefaultFilters = false
    )
})
public class BookTransfersApplication {

    public static void main(String[] args) {
        SpringApplication.run(BookTransfersApplication.class, args);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./app/src/main/java/dexter/banking/booktransfers/app/config/BeanConfiguration.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.app.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import dexter.banking.commandbus.CommandBus;
import dexter.banking.commandbus.CommandDispatcher;
import dexter.banking.commandbus.CommandHandler;
import dexter.banking.commandbus.Middleware;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import java.util.List;

@Configuration
public class BeanConfiguration {

    @Bean
    public CommandBus commandBus(List<CommandHandler<?, ?>> commandHandlers,
                                 List<Middleware> middlewares) {
        return CommandDispatcher.builder()
                .withMiddlewares(middlewares) // Spring provides this list pre-ordered
                .withCommandHandlers(commandHandlers)
                .build();
    }

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        return objectMapper;
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./app/src/main/java/dexter/banking/booktransfers/app/config/JmsConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.app.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.support.converter.MappingJackson2MessageConverter;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.converter.MessageType;

@Configuration
public class JmsConfig {
    public static final String TYPE_PROP_NAME = "_type";

    @Bean
    public MessageConverter messageConverter(ObjectMapper objectMapper) {
        MappingJackson2MessageConverter converter = new MappingJackson2MessageConverter();
        converter.setTargetType(MessageType.TEXT);
        converter.setTypeIdPropertyName(TYPE_PROP_NAME);
        converter.setObjectMapper(objectMapper);
        return converter;
    }
}



<<--FILE_END-->>
<<--FILE_START-->>
Path: ./app/src/main/java/dexter/banking/booktransfers/app/config/LocalDiscoveryConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.app.config;

import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.context.annotation.Configuration;

@EnableDiscoveryClient
@Configuration
public class LocalDiscoveryConfig {
}



<<--FILE_END-->>
<<--FILE_START-->>
Path: ./app/src/main/java/dexter/banking/booktransfers/app/config/MongoConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.app.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.mongodb.core.convert.MongoCustomConversions;

import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.Arrays;
import java.util.Date;

@Configuration
public class MongoConfig {

    @Bean
    public MongoCustomConversions mongoCustomConversions() {
        return new MongoCustomConversions(Arrays.asList(
                new OffsetDateTimeReadConverter(),
                new OffsetDateTimeWriteConverter()
        ));
    }

    static class OffsetDateTimeWriteConverter implements Converter<OffsetDateTime, Date> {
        @Override
        public Date convert(OffsetDateTime source) {
            return source == null ? null : Date.from(source.toInstant().atZone(ZoneOffset.UTC).toInstant());
        }
    }

    static class OffsetDateTimeReadConverter implements Converter<Date, OffsetDateTime> {
        @Override
        public OffsetDateTime convert(Date source) {
            return source == null ? null : source.toInstant().atOffset(ZoneOffset.UTC);
        }
    }
}


<<--FILE_END-->>
<<--FILE_START-->>
Path: ./app/src/main/resources/application.yml
<<--CONTENT_START-->>
spring:
  application:
    name: book-transfers-service
  config:
    import: "optional:configserver:"
  cloud:
    config:
      discovery:
        enabled: true
        service-id: payment-config-server
      fail-fast: true
      username: configUser
      password: configPassword
  jms:
    listener:
      concurrency: 5
      max-concurrency: 10
  jackson:
    default-property-inclusion: non_null
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

management:
  tracing:
    sampling:
      probability: 1.0
    logging:
      enabled: true

eureka:
  instance:
    prefer-ip-address: true
  client:
    serviceUrl:
      defaultZone: http://eurekaUser:eurekaPassword@localhost:8761/eureka/

# Business process configuration is preserved
service-config:
  journeys:
    PAYMENT_SUBMIT_V1:
      idempotencyEnabled: true
      policies:
        - "stateTransitionPolicy"
    PAYMENT_SUBMIT_V2_SYNC:
      idempotencyEnabled: true
      policies:
        - "stateTransitionPolicy"
    PAYMENT_SUBMIT_V2_ASYNC:
      idempotencyEnabled: false
      policies:
        - "stateTransitionPolicy"
    PAYMENT_SUBMIT_V3:
      idempotencyEnabled: true
      policies:
        - "stateTransitionPolicy"
      complianceThreshold: 10000.00

logging:
  level:
    tech: debug
    dexter.banking.booktransfers.infrastructure.middleware: debug
    dexter.banking.booktransfers.core.usecase: info
    org.springframework.transaction.event: warn

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./app/src/test/java/dexter/banking/booktransfers/BookTransfersApplicationTests.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

//@SpringBootTest
class BookTransfersApplicationTests {

    @Test
    void contextLoads() {
    }

}


<<--FILE_END-->>
<<--FILE_START-->>
Path: ./app/target/classes/application.yml
<<--CONTENT_START-->>
spring:
  application:
    name: book-transfers-service
  config:
    import: "optional:configserver:"
  cloud:
    config:
      discovery:
        enabled: true
        service-id: payment-config-server
      fail-fast: true
      username: configUser
      password: configPassword
  jms:
    listener:
      concurrency: 5
      max-concurrency: 10
  jackson:
    default-property-inclusion: non_null
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

management:
  tracing:
    sampling:
      probability: 1.0
    logging:
      enabled: true

eureka:
  instance:
    prefer-ip-address: true
  client:
    serviceUrl:
      defaultZone: http://eurekaUser:eurekaPassword@localhost:8761/eureka/

# Business process configuration is preserved
service-config:
  journeys:
    PAYMENT_SUBMIT_V1:
      idempotencyEnabled: true
      policies:
        - "stateTransitionPolicy"
    PAYMENT_SUBMIT_V2_SYNC:
      idempotencyEnabled: true
      policies:
        - "stateTransitionPolicy"
    PAYMENT_SUBMIT_V2_ASYNC:
      idempotencyEnabled: false
      policies:
        - "stateTransitionPolicy"
    PAYMENT_SUBMIT_V3:
      idempotencyEnabled: true
      policies:
        - "stateTransitionPolicy"
      complianceThreshold: 10000.00

logging:
  level:
    tech: debug
    dexter.banking.booktransfers.infrastructure.middleware: debug
    dexter.banking.booktransfers.core.usecase: info
    org.springframework.transaction.event: warn

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/pom.xml
<<--CONTENT_START-->>
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>dexter.demo.payment</groupId>
        <artifactId>book-transfers-service</artifactId>
        <version>0.1.0-SNAPSHOT</version>
    </parent>

    <artifactId>book-transfers-core</artifactId>
    <name>Book Transfers :: Core</name>
    <description>The core business logic module (domain, application, ports).</description>

    <dependencies>
        <dependency>
            <groupId>dexter.demo.payment</groupId>
            <artifactId>common-domain</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>jakarta.validation</groupId>
            <artifactId>jakarta.validation-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-tx</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-annotations</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
        </dependency>
    </dependencies>

</project>

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/compliance/command/ApproveComplianceCaseCommand.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.compliance.command;

import dexter.banking.commandbus.Command;

import java.util.UUID;

public record ApproveComplianceCaseCommand(
    UUID complianceCaseId
) implements Command<Void> {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/compliance/command/ApproveComplianceCaseCommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.compliance.command;

import dexter.banking.booktransfers.core.domain.compliance.ComplianceCase;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.port.in.compliance.ApproveComplianceCaseUseCase;
import dexter.banking.booktransfers.core.port.out.ComplianceCaseRepositoryPort;
import dexter.banking.booktransfers.core.port.out.EventDispatcherPort;
import dexter.banking.commandbus.CommandHandler;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
@RequiredArgsConstructor
public class ApproveComplianceCaseCommandHandler implements CommandHandler<ApproveComplianceCaseCommand, Void> {
    private final ComplianceCaseRepositoryPort complianceCaseRepository;
    private final EventDispatcherPort eventDispatcher;
    @Override
    @Transactional
    public Void handle(ApproveComplianceCaseCommand command) {
        ComplianceCase complianceCase = complianceCaseRepository.findById(command.complianceCaseId())
                .orElseThrow(() -> new TransactionNotFoundException("ComplianceCase not found: " + command.complianceCaseId()));
        complianceCase.approve();

        complianceCaseRepository.save(complianceCase);
        eventDispatcher.dispatch(complianceCase.pullDomainEvents());
        return null;
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/compliance/command/RejectComplianceCaseCommand.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.compliance.command;

import dexter.banking.commandbus.Command;

import java.util.UUID;

public record RejectComplianceCaseCommand(
        UUID complianceCaseId,
        String reason
) implements Command<Void> {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/compliance/command/RejectComplianceCaseCommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.compliance.command;

import dexter.banking.booktransfers.core.domain.compliance.ComplianceCase;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.port.in.compliance.RejectComplianceCaseUseCase;
import dexter.banking.booktransfers.core.port.in.payment.FailPaymentUseCase;
import dexter.banking.booktransfers.core.port.out.ComplianceCaseRepositoryPort;
import dexter.banking.booktransfers.core.port.out.EventDispatcherPort;
import dexter.banking.commandbus.CommandHandler;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
@RequiredArgsConstructor
public class RejectComplianceCaseCommandHandler implements CommandHandler<RejectComplianceCaseCommand, Void> {
    private final ComplianceCaseRepositoryPort complianceCaseRepository;
    private final EventDispatcherPort eventDispatcher;

    @Override
    @Transactional
    public Void handle(RejectComplianceCaseCommand command) {
        ComplianceCase complianceCase = complianceCaseRepository.findById(command.complianceCaseId())
                .orElseThrow(() -> new TransactionNotFoundException("ComplianceCase not found: " + command.complianceCaseId()));
        complianceCase.reject(command.reason());

        complianceCaseRepository.save(complianceCase);
        eventDispatcher.dispatch(complianceCase.pullDomainEvents());
        return null;
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/compliance/CreateComplianceCaseService.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.compliance;

import dexter.banking.booktransfers.core.domain.compliance.ComplianceCase;
import dexter.banking.booktransfers.core.port.in.compliance.CreateComplianceCaseUseCase;
import dexter.banking.booktransfers.core.port.out.ComplianceCaseRepositoryPort;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
@RequiredArgsConstructor
public class CreateComplianceCaseService implements CreateComplianceCaseUseCase {
    private final ComplianceCaseRepositoryPort complianceCaseRepository;

    @Override
    @Transactional
    public void create(UUID paymentId) {
        // This service's sole responsibility is to create the case in its initial state.
        ComplianceCase complianceCase = ComplianceCase.create(paymentId);
        complianceCaseRepository.save(complianceCase);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/compliance/query/ComplianceCaseView.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.compliance.query;

import dexter.banking.booktransfers.core.domain.compliance.ComplianceStatus;

import java.util.UUID;

/**
 * The dedicated Read Model for compliance case queries.
 * This is an immutable, flat DTO containing only the data needed by query clients.
 */
public record ComplianceCaseView(
    UUID caseId,
    UUID paymentId,
    ComplianceStatus status
) {}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/middleware/ConfigurationEnrichmentMiddleware.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.middleware;

import dexter.banking.booktransfers.core.domain.shared.config.CommandProcessingContext;
import dexter.banking.booktransfers.core.domain.shared.config.CommandProcessingContextHolder;
import dexter.banking.booktransfers.core.port.out.ConfigurationPort;
import dexter.banking.commandbus.Command;
import dexter.banking.commandbus.Middleware;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

/**
 * An inbound adapter that acts as a Middleware.
 * Its responsibility is to fetch configuration via the ConfigurationPort and enrich
 * the current request context, making it available to downstream core components.
 */
@Order(1)
@Component
@RequiredArgsConstructor
@Slf4j
public class ConfigurationEnrichmentMiddleware implements Middleware {

    private final ConfigurationPort configurationPort;

    @Override
    public <R, C extends Command<R>> R invoke(C command, Next<R> next) {
        String identifier = command.getIdentifier();
        // This middleware now correctly depends on a core port, not an infrastructure detail.
        configurationPort.findForJourney(identifier).ifPresent(spec -> {
            CommandProcessingContext context = new CommandProcessingContext(spec);
            CommandProcessingContextHolder.setContext(context);
            log.debug("Service config for '{}' loaded into context.", identifier);
        });

        if (CommandProcessingContextHolder.getContext().isEmpty()) {
            log.warn("No service configuration found for command identifier: '{}'. Proceeding without configuration.", identifier);
        }

        try {
            return next.invoke();
        } finally {
            // CRUCIAL: Always clear the context to prevent memory leaks in a threaded environment.
            if (CommandProcessingContextHolder.getContext().isPresent()) {
                CommandProcessingContextHolder.clearContext();
                log.debug("Context cleared for command identifier: '{}'", identifier);
            }
        }
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/middleware/IdempotencyMiddleware.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.middleware;

import dexter.banking.booktransfers.core.domain.payment.exception.IdempotencyConflictException;
import dexter.banking.booktransfers.core.domain.shared.config.CommandProcessingContextHolder;
import dexter.banking.booktransfers.core.domain.shared.idempotency.IdempotencyData;
import dexter.banking.booktransfers.core.domain.shared.idempotency.IdempotencyStatus;
import dexter.banking.booktransfers.core.port.out.IdempotencyPort;
import dexter.banking.commandbus.Command;
import dexter.banking.commandbus.IdempotentCommand;
import dexter.banking.commandbus.Middleware;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Order(2)
@Component
@RequiredArgsConstructor
@Slf4j
public class IdempotencyMiddleware implements Middleware {

    private final IdempotencyPort idempotencyPort;

    @Override
    @SuppressWarnings("unchecked")
    public <R, C extends Command<R>> R invoke(C command, Next<R> next) {
        // This middleware is now pure. It depends only on the core context and core ports.
        boolean isApplicable = CommandProcessingContextHolder.getContext()
                .map(ctx -> ctx.getJourneySpecification().isIdempotencyEnabled())
                .orElse(false);

        if (!isApplicable || !(command instanceof IdempotentCommand<?> idempotentCommand)) {
            return next.invoke();
        }

        UUID key = idempotentCommand.getIdempotencyKey();

        // Step 1: Attempt to acquire the lock. This is the hot path for new requests.
        if (idempotencyPort.tryAcquireLock(key)) {
            // Lock was acquired successfully. This is a new request.
            log.info("New idempotency key {}, lock acquired. Proceeding with new request.", key);
            try {
                R response = next.invoke();
                idempotencyPort.markCompleted(key, response);
                return response;
            } catch (Exception e) {
                idempotencyPort.releaseLock(key);
                throw e; // Rethrow the original exception
            }
        } else {
            // Lock was NOT acquired. Key already exists. Now, we find out why.
            log.debug("Idempotency key {} already exists. Fetching status...", key);
            IdempotencyData record = idempotencyPort.getOperationData(key)
                    .orElseThrow(() -> new IllegalStateException("FATAL: Lock failed but no record found for key: " + key)); // Should be impossible

            if (record.status() == IdempotencyStatus.COMPLETED) {
                // It's a duplicate request.
                log.info("Idempotency key {} already completed. Returning saved response.", key);
                return (R) record.response();
            } else { // status is STARTED
                // It's a concurrent request.
                log.warn("Idempotency key {} is already in progress.", key);
                throw new IdempotencyConflictException("Request with key " + key + " is already being processed.");
            }
        }
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/AsyncPaymentV2CommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command;

import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.OrchestrationContextMapper;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.domain.payment.ApiVersion;
import dexter.banking.booktransfers.core.domain.payment.ModeOfTransfer;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.PaymentResult;
import dexter.banking.booktransfers.core.domain.shared.config.CommandProcessingContext;
import dexter.banking.booktransfers.core.domain.shared.config.CommandProcessingContextHolder;
import dexter.banking.booktransfers.core.domain.shared.config.JourneySpecification;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.commandbus.CommandHandler;
import dexter.banking.statemachine.StateMachineFactory;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Component
@RequiredArgsConstructor
@Slf4j
public class AsyncPaymentV2CommandHandler implements CommandHandler<PaymentCommand, PaymentResult> {

    private final StateMachineFactory<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> stateMachineFactory;
    private final PaymentRepositoryPort paymentRepository;
    private final BusinessPolicyFactory policyFactory;
    private final OrchestrationContextMapper orchestrationContextMapper;

    @Override
    public boolean matches(PaymentCommand command) {
        return command.getVersion() == ApiVersion.V2 && command.getModeOfTransfer() == ModeOfTransfer.ASYNC;
    }

    @Override
    @Transactional
    public PaymentResult handle(PaymentCommand command) {
        JourneySpecification spec = CommandProcessingContextHolder.getContext()
                .map(CommandProcessingContext::getJourneySpecification)
                .orElseThrow(() -> new IllegalStateException("JourneySpecification not found in context for async submission"));
        BusinessPolicy policy = policyFactory.create(spec);

        UUID transactionId = UUID.randomUUID();
        String journeyName = command.getIdentifier();

        var creationParams = new Payment.PaymentCreationParams(
                transactionId,
                command.getTransactionReference(),
                journeyName
        );

        Payment payment = Payment.startNew(creationParams, policy);
        paymentRepository.save(payment);

        var context = orchestrationContextMapper.toNewContext(payment.getId(), command);
        var stateMachine = stateMachineFactory.acquireStateMachine(context);
        stateMachine.fire(AsyncProcessEvent.SUBMIT);

        return PaymentResult.from(payment);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/callback/ProcessCreditCardResultCommand.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command.callback;

import dexter.banking.booktransfers.core.domain.payment.valueobject.result.CreditLegResult;
import dexter.banking.commandbus.Command;

import java.util.UUID;

/**
 * A dedicated, internal command to process the result of a credit card leg callback.
 */
public record ProcessCreditCardResultCommand(
        UUID transactionId,
        CreditLegResult result
) implements Command<Void> {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/callback/ProcessCreditCardResultCommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command.callback;

import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.CreditLegResult;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import dexter.banking.booktransfers.core.port.out.ConfigurationPort;
import dexter.banking.booktransfers.core.port.out.EventDispatcherPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.commandbus.CommandHandler;
import dexter.banking.statemachine.StateMachineFactory;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class ProcessCreditCardResultCommandHandler implements CommandHandler<ProcessCreditCardResultCommand, Void> {

    private final PaymentRepositoryPort paymentRepository;
    private final ConfigurationPort configurationPort;
    private final BusinessPolicyFactory policyFactory;
    private final EventDispatcherPort eventDispatcher;

    @Qualifier("asyncTransactionFsmFactory")
    private final StateMachineFactory<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> v2StateMachineFactory;
    @Qualifier("v3TransactionFsmFactory")
    private final StateMachineFactory<ProcessStateV3, ProcessEventV3, HybridTransactionContext> v3StateMachineFactory;

    @Override
    @Transactional
    public Void handle(ProcessCreditCardResultCommand command) {
        log.info("Handling credit card callback for transactionId: {}", command.transactionId());

        Payment.PaymentMemento memento = paymentRepository.findMementoById(command.transactionId())
                .orElseThrow(() -> new TransactionNotFoundException("Transaction not found for ID: " + command.transactionId()));

        Payment payment = rehydratePayment(memento);

        payment.recordCredit(command.result(), Collections.emptyMap());

        paymentRepository.update(payment);
        eventDispatcher.dispatch(payment.pullDomainEvents());

        // Universal Routing Logic
        String journeyName = memento.journeyName();
        if (journeyName.contains("V2_ASYNC")) {
            resumeV2Orchestration(command, memento);
        } else if (journeyName.contains("V3")) {
            resumeV3Orchestration(command, memento);
        } else {
            log.error("Unknown journeyName '{}' for callback on transactionId {}", journeyName, command.transactionId());
        }

        return null;
    }

    private void resumeV2Orchestration(ProcessCreditCardResultCommand command, Payment.PaymentMemento memento) {
        v2StateMachineFactory.acquireStateMachine(memento.id().toString()).ifPresentOrElse(
                stateMachine -> {
                    AsyncProcessEvent event = command.result().status() == CreditLegResult.CreditLegStatus.SUCCESSFUL ?
                            AsyncProcessEvent.CREDIT_LEG_SUCCEEDED : AsyncProcessEvent.CREDIT_LEG_FAILED;
                    stateMachine.fire(event);
                },
                () -> log.error("Could not acquire V2 state machine for transaction id: {}", command.transactionId())
        );
    }

    private void resumeV3Orchestration(ProcessCreditCardResultCommand command, Payment.PaymentMemento memento) {
        v3StateMachineFactory.acquireStateMachine(memento.id().toString()).ifPresentOrElse(
                stateMachine -> {
                    ProcessEventV3 event = command.result().status() == CreditLegResult.CreditLegStatus.SUCCESSFUL ?
                            ProcessEventV3.CREDIT_LEG_SUCCEEDED : ProcessEventV3.CREDIT_LEG_FAILED;
                    stateMachine.fire(event);
                },
                () -> log.error("Could not acquire V3 state machine for transaction id: {}", command.transactionId())
        );
    }

    private Payment rehydratePayment(Payment.PaymentMemento memento) {
        BusinessPolicy policy = configurationPort
                .findForJourney(memento.journeyName())
                .map(policyFactory::create)
                .orElseThrow(() -> new IllegalStateException("No journey configured for identifier: " + memento.journeyName()));
        return Payment.rehydrate(memento, policy);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/callback/ProcessDebitResultCommand.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command.callback;

import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.commandbus.Command;

import java.util.UUID;

/**
 * A dedicated, internal command to process the result of a debit leg callback.
 */
public record ProcessDebitResultCommand(
        UUID transactionId,
        DebitLegResult result
) implements Command<Void> {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/callback/ProcessDebitResultCommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command.callback;

import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import dexter.banking.booktransfers.core.port.out.ConfigurationPort;
import dexter.banking.booktransfers.core.port.out.EventDispatcherPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.commandbus.CommandHandler;
import dexter.banking.statemachine.StateMachineFactory;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;

@Slf4j
@Component
@RequiredArgsConstructor
public class ProcessDebitResultCommandHandler implements CommandHandler<ProcessDebitResultCommand, Void> {

    private final PaymentRepositoryPort paymentRepository;
    private final ConfigurationPort configurationPort;
    private final BusinessPolicyFactory policyFactory;
    private final EventDispatcherPort eventDispatcher;

    @Qualifier("asyncTransactionFsmFactory")
    private final StateMachineFactory<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> v2StateMachineFactory;
    @Qualifier("v3TransactionFsmFactory")
    private final StateMachineFactory<ProcessStateV3, ProcessEventV3, HybridTransactionContext> v3StateMachineFactory;


    @Override
    @Transactional
    public Void handle(ProcessDebitResultCommand command) {
        log.info("Handling debit callback for transactionId: {}", command.transactionId());

        Payment.PaymentMemento memento = paymentRepository.findMementoById(command.transactionId())
                .orElseThrow(() -> new TransactionNotFoundException("Transaction not found for ID: " + command.transactionId()));

        Payment payment = rehydratePayment(memento);

        payment.recordDebit(command.result(), Collections.emptyMap());

        paymentRepository.update(payment);
        eventDispatcher.dispatch(payment.pullDomainEvents());

        // Universal Routing Logic
        String journeyName = memento.journeyName();
        if (journeyName.contains("V2_ASYNC")) {
            resumeV2Orchestration(command, memento);
        } else if (journeyName.contains("V3")) {
            resumeV3Orchestration(command, memento);
        } else {
            log.error("Unknown journeyName '{}' for callback on transactionId {}", journeyName, command.transactionId());
        }

        return null;
    }

    private void resumeV2Orchestration(ProcessDebitResultCommand command, Payment.PaymentMemento memento) {
        v2StateMachineFactory.acquireStateMachine(memento.id().toString()).ifPresentOrElse(
                stateMachine -> {
                    AsyncProcessEvent event = command.result().status() == DebitLegResult.DebitLegStatus.SUCCESSFUL ?
                            AsyncProcessEvent.DEBIT_LEG_SUCCEEDED : AsyncProcessEvent.DEBIT_LEG_FAILED;
                    stateMachine.fire(event);
                },
                () -> log.error("Could not acquire V2 state machine for transaction id: {}", command.transactionId())
        );
    }

    private void resumeV3Orchestration(ProcessDebitResultCommand command, Payment.PaymentMemento memento) {
        v3StateMachineFactory.acquireStateMachine(memento.id().toString()).ifPresentOrElse(
                stateMachine -> {
                    ProcessEventV3 event = command.result().status() == DebitLegResult.DebitLegStatus.SUCCESSFUL ?
                            ProcessEventV3.DEBIT_LEG_SUCCEEDED : ProcessEventV3.DEBIT_LEG_FAILED;
                    stateMachine.fire(event);
                },
                () -> log.error("Could not acquire V3 state machine for transaction id: {}", command.transactionId())
        );
    }

    private Payment rehydratePayment(Payment.PaymentMemento memento) {
        BusinessPolicy policy = configurationPort
                .findForJourney(memento.journeyName())
                .map(policyFactory::create)
                .orElseThrow(() -> new IllegalStateException("No journey configured for identifier: " + memento.journeyName()));
        return Payment.rehydrate(memento, policy);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/callback/ProcessDebitReversalResultCommand.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command.callback;

import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.commandbus.Command;

import java.util.UUID;

/**
 * A dedicated, internal command to process the result of a debit leg reversal callback.
 */
public record ProcessDebitReversalResultCommand(
        UUID transactionId,
        DebitLegResult result
) implements Command<Void> {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/callback/ProcessDebitReversalResultCommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command.callback;

import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import dexter.banking.booktransfers.core.port.out.ConfigurationPort;
import dexter.banking.booktransfers.core.port.out.EventDispatcherPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.commandbus.CommandHandler;
import dexter.banking.statemachine.StateMachineFactory;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;

@Slf4j
@Component
@RequiredArgsConstructor
public class ProcessDebitReversalResultCommandHandler implements CommandHandler<ProcessDebitReversalResultCommand, Void> {

    private final PaymentRepositoryPort paymentRepository;
    private final ConfigurationPort configurationPort;
    private final BusinessPolicyFactory policyFactory;
    private final EventDispatcherPort eventDispatcher;

    @Qualifier("asyncTransactionFsmFactory")
    private final StateMachineFactory<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> v2StateMachineFactory;
    @Qualifier("v3TransactionFsmFactory")
    private final StateMachineFactory<ProcessStateV3, ProcessEventV3, HybridTransactionContext> v3StateMachineFactory;

    @Override
    @Transactional
    public Void handle(ProcessDebitReversalResultCommand command) {
        log.info("Handling debit reversal callback for transactionId: {}", command.transactionId());

        Payment.PaymentMemento memento = paymentRepository.findMementoById(command.transactionId())
                .orElseThrow(() -> new TransactionNotFoundException("Transaction not found for ID: " + command.transactionId()));

        Payment payment = rehydratePayment(memento);

        payment.recordDebitReversal(command.result(), Collections.emptyMap());

        paymentRepository.update(payment);
        eventDispatcher.dispatch(payment.pullDomainEvents());

        // Universal Routing Logic
        String journeyName = memento.journeyName();
        if (journeyName.contains("V2_ASYNC")) {
            resumeV2Orchestration(command, memento);
        } else if (journeyName.contains("V3")) {
            resumeV3Orchestration(command, memento);
        } else {
            log.error("Unknown journeyName '{}' for callback on transactionId {}", journeyName, command.transactionId());
        }

        return null;
    }

    private void resumeV2Orchestration(ProcessDebitReversalResultCommand command, Payment.PaymentMemento memento) {
        v2StateMachineFactory.acquireStateMachine(memento.id().toString()).ifPresentOrElse(
                stateMachine -> {
                    AsyncProcessEvent event = command.result().status() == DebitLegResult.DebitLegStatus.REVERSAL_SUCCESSFUL ?
                            AsyncProcessEvent.DEBIT_LEG_REVERSAL_SUCCEEDED : AsyncProcessEvent.DEBIT_LEG_REVERSAL_FAILED;
                    stateMachine.fire(event);
                },
                () -> log.error("Could not acquire V2 state machine for transaction id: {}", command.transactionId())
        );
    }

    private void resumeV3Orchestration(ProcessDebitReversalResultCommand command, Payment.PaymentMemento memento) {
        v3StateMachineFactory.acquireStateMachine(memento.id().toString()).ifPresentOrElse(
                stateMachine -> {
                    ProcessEventV3 event = command.result().status() == DebitLegResult.DebitLegStatus.REVERSAL_SUCCESSFUL ?
                            ProcessEventV3.DEBIT_LEG_REVERSAL_SUCCEEDED : ProcessEventV3.DEBIT_LEG_REVERSAL_FAILED;
                    stateMachine.fire(event);
                },
                () -> log.error("Could not acquire V3 state machine for transaction id: {}", command.transactionId())
        );
    }

    private Payment rehydratePayment(Payment.PaymentMemento memento) {
        BusinessPolicy policy = configurationPort
                .findForJourney(memento.journeyName())
                .map(policyFactory::create)
                .orElseThrow(() -> new IllegalStateException("No journey configured for identifier: " + memento.journeyName()));
        return Payment.rehydrate(memento, policy);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/callback/ProcessLimitEarmarkResultCommand.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command.callback;

import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import dexter.banking.commandbus.Command;

import java.util.UUID;

/**
 * A dedicated, internal command to process the result of a limit earmark callback.
 */
public record ProcessLimitEarmarkResultCommand(
        UUID transactionId,
        LimitEarmarkResult result
) implements Command<Void> {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/callback/ProcessLimitEarmarkResultCommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command.callback;

import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import dexter.banking.booktransfers.core.port.out.ConfigurationPort;
import dexter.banking.booktransfers.core.port.out.EventDispatcherPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.commandbus.CommandHandler;
import dexter.banking.statemachine.StateMachineFactory;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;

@Slf4j
@Component
@RequiredArgsConstructor
public class ProcessLimitEarmarkResultCommandHandler implements CommandHandler<ProcessLimitEarmarkResultCommand, Void> {

    private final PaymentRepositoryPort paymentRepository;
    private final ConfigurationPort configurationPort;
    private final BusinessPolicyFactory policyFactory;
    private final EventDispatcherPort eventDispatcher;

    @Qualifier("asyncTransactionFsmFactory")
    private final StateMachineFactory<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> v2StateMachineFactory;
    @Qualifier("v3TransactionFsmFactory")
    private final StateMachineFactory<ProcessStateV3, ProcessEventV3, HybridTransactionContext> v3StateMachineFactory;

    @Override
    @Transactional
    public Void handle(ProcessLimitEarmarkResultCommand command) {
        log.info("Handling limit earmark callback for transactionId: {}", command.transactionId());

        Payment.PaymentMemento memento = paymentRepository.findMementoById(command.transactionId())
                .orElseThrow(() -> new TransactionNotFoundException("Transaction not found for ID: " + command.transactionId()));

        Payment payment = rehydratePayment(memento);

        payment.recordLimitEarmark(command.result(), Collections.emptyMap());

        paymentRepository.update(payment);
        eventDispatcher.dispatch(payment.pullDomainEvents());

        // Universal Routing Logic - V3 does not have async limit earmark, so this only applies to V2.
        String journeyName = memento.journeyName();
        if (journeyName.contains("V2_ASYNC")) {
            resumeV2Orchestration(command, memento);
        } else {
            log.warn("Received a Limit Earmark callback for a non-V2-Async journey '{}'. Ignoring. TXN_ID: {}", journeyName, command.transactionId());
        }

        return null;
    }

    private void resumeV2Orchestration(ProcessLimitEarmarkResultCommand command, Payment.PaymentMemento memento) {
        v2StateMachineFactory.acquireStateMachine(memento.id().toString()).ifPresentOrElse(
                stateMachine -> {
                    AsyncProcessEvent event = command.result().status() == LimitEarmarkResult.LimitEarmarkStatus.SUCCESSFUL ?
                            AsyncProcessEvent.LIMIT_EARMARK_SUCCEEDED : AsyncProcessEvent.LIMIT_EARMARK_FAILED;
                    stateMachine.fire(event);
                },
                () -> log.error("Could not acquire V2 state machine for transaction id: {}", command.transactionId())
        );
    }

    private Payment rehydratePayment(Payment.PaymentMemento memento) {
        BusinessPolicy policy = configurationPort
                .findForJourney(memento.journeyName())
                .map(policyFactory::create)
                .orElseThrow(() -> new IllegalStateException("No journey configured for identifier: " + memento.journeyName()));
        return Payment.rehydrate(memento, policy);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/callback/ProcessLimitReversalResultCommand.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command.callback;

import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import dexter.banking.commandbus.Command;

import java.util.UUID;

/**
 * A dedicated, internal command to process the result of a limit earmark reversal callback.
 */
public record ProcessLimitReversalResultCommand(
        UUID transactionId,
        LimitEarmarkResult result
) implements Command<Void> {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/callback/ProcessLimitReversalResultCommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command.callback;

import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import dexter.banking.booktransfers.core.port.out.ConfigurationPort;
import dexter.banking.booktransfers.core.port.out.EventDispatcherPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.commandbus.CommandHandler;
import dexter.banking.statemachine.StateMachineFactory;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;

@Slf4j
@Component
@RequiredArgsConstructor
public class ProcessLimitReversalResultCommandHandler implements CommandHandler<ProcessLimitReversalResultCommand, Void> {

    private final PaymentRepositoryPort paymentRepository;
    private final ConfigurationPort configurationPort;
    private final BusinessPolicyFactory policyFactory;
    private final EventDispatcherPort eventDispatcher;

    @Qualifier("asyncTransactionFsmFactory")
    private final StateMachineFactory<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> v2StateMachineFactory;
    @Qualifier("v3TransactionFsmFactory")
    private final StateMachineFactory<ProcessStateV3, ProcessEventV3, HybridTransactionContext> v3StateMachineFactory;


    @Override
    @Transactional
    public Void handle(ProcessLimitReversalResultCommand command) {
        log.info("Handling limit reversal callback for transactionId: {}", command.transactionId());

        Payment.PaymentMemento memento = paymentRepository.findMementoById(command.transactionId())
                .orElseThrow(() -> new TransactionNotFoundException("Transaction not found for ID: " + command.transactionId()));

        Payment payment = rehydratePayment(memento);

        payment.recordLimitReversal(command.result(), Collections.emptyMap());

        paymentRepository.update(payment);
        eventDispatcher.dispatch(payment.pullDomainEvents());

        // Universal Routing Logic - V3 does not have async limit reversal, so this only applies to V2.
        String journeyName = memento.journeyName();
        if (journeyName.contains("V2_ASYNC")) {
            resumeV2Orchestration(command, memento);
        } else {
            log.warn("Received a Limit Reversal callback for a non-V2-Async journey '{}'. Ignoring. TXN_ID: {}", journeyName, command.transactionId());
        }

        return null;
    }

    private void resumeV2Orchestration(ProcessLimitReversalResultCommand command, Payment.PaymentMemento memento) {
        v2StateMachineFactory.acquireStateMachine(memento.id().toString()).ifPresentOrElse(
                stateMachine -> {
                    AsyncProcessEvent event = command.result().status() == LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_SUCCESSFUL ?
                            AsyncProcessEvent.LIMIT_EARMARK_REVERSAL_SUCCEEDED : AsyncProcessEvent.LIMIT_EARMARK_REVERSAL_FAILED;
                    stateMachine.fire(event);
                },
                () -> log.error("Could not acquire V2 state machine for transaction id: {}", command.transactionId())
        );
    }

    private Payment rehydratePayment(Payment.PaymentMemento memento) {
        BusinessPolicy policy = configurationPort
                .findForJourney(memento.journeyName())
                .map(policyFactory::create)
                .orElseThrow(() -> new IllegalStateException("No journey configured for identifier: " + memento.journeyName()));
        return Payment.rehydrate(memento, policy);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/FailPaymentCommand.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command;

import dexter.banking.commandbus.Command;

import java.util.UUID;

public record FailPaymentCommand(
        UUID paymentId,
        String reason
) implements Command<Void> {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/FailPaymentCommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command;

import dexter.banking.booktransfers.core.port.in.payment.FailPaymentParams;
import dexter.banking.booktransfers.core.port.in.payment.FailPaymentUseCase;
import dexter.banking.commandbus.CommandHandler;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
@RequiredArgsConstructor
public class FailPaymentCommandHandler implements CommandHandler<FailPaymentCommand, Void> {
    private final FailPaymentUseCase failPaymentUseCase;
    @Override
    @Transactional
    public Void handle(FailPaymentCommand command) {
        var params = new FailPaymentParams(command.paymentId(), command.reason());
        failPaymentUseCase.fail(params);
        return null;
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/HighValuePaymentCommand.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command;

import dexter.banking.booktransfers.core.domain.payment.ApiVersion;
import dexter.banking.booktransfers.core.domain.payment.PaymentResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.RelId;
import dexter.banking.booktransfers.core.domain.payment.valueobject.TransactionAmount;
import dexter.banking.commandbus.IdempotentCommand;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Builder;
import lombok.Value;

import java.util.UUID;

@Value
@Builder
public class HighValuePaymentCommand implements IdempotentCommand<PaymentResult> {
    @NotNull
    UUID idempotencyKey;
    @NotBlank
    String transactionReference;
    @NotNull
    RelId relId;
    @NotNull
    TransactionAmount transactionAmount;

    @NotBlank
    String limitType;
    @NotBlank
    String accountNumber;
    @NotBlank
    String cardNumber;


    @Override
    public String getIdentifier() {
        return "PAYMENT_SUBMIT_" + ApiVersion.V3.name();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/PaymentCommand.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command;
import dexter.banking.booktransfers.core.domain.payment.ApiVersion;
import dexter.banking.booktransfers.core.domain.payment.ModeOfTransfer;
import dexter.banking.booktransfers.core.domain.payment.PaymentResult;
import dexter.banking.commandbus.IdempotentCommand;
import lombok.*;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.util.UUID;
@Value
@Builder
public class PaymentCommand implements IdempotentCommand<PaymentResult> {

    @NotNull
    UUID idempotencyKey;

    @NotBlank
    String transactionReference;
    @NotBlank
    String limitType;
    @NotBlank
    String accountNumber;
    @NotBlank
    String cardNumber;

    String webhookUrl;
    String realtime;
    @NotNull
    @Builder.Default
    ModeOfTransfer modeOfTransfer = ModeOfTransfer.ASYNC;

    // The new version discriminator field.
    @NotNull
    private final ApiVersion version;

    /**
     * The identifier is now dynamic, allowing for version-specific configuration
     * of middleware behaviors like idempotency or orchestration strategy selection.
     */
    @Override
    public String getIdentifier() {
        if (this.version == ApiVersion.V2) {
            // The identifier is now granular for V2, enabling distinct configurations.
            return "PAYMENT_SUBMIT_V2_" + this.modeOfTransfer.name();
        }
        return "PAYMENT_SUBMIT_" + this.version.name();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/ResumePaymentCommand.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command;

import dexter.banking.commandbus.Command;

import java.util.UUID;

public record ResumePaymentCommand(
        UUID paymentId
) implements Command<Void> {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/ResumePaymentCommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command;

import dexter.banking.booktransfers.core.port.in.payment.ResumePaymentParams;
import dexter.banking.booktransfers.core.port.in.payment.ResumePaymentUseCase;
import dexter.banking.commandbus.CommandHandler;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
@RequiredArgsConstructor
public class ResumePaymentCommandHandler implements CommandHandler<ResumePaymentCommand, Void> {
    private final ResumePaymentUseCase resumePaymentUseCase;
    @Override
    @Transactional
    public Void handle(ResumePaymentCommand command) {
        var params = new ResumePaymentParams(command.paymentId());
        this.resumePaymentUseCase.resume(params);
        return null;
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/SubmitPaymentV1CommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command;
import dexter.banking.booktransfers.core.domain.payment.ApiVersion;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.PaymentResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.CreditLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import dexter.banking.booktransfers.core.domain.shared.config.CommandProcessingContextHolder;
import dexter.banking.booktransfers.core.domain.shared.config.JourneySpecification;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.*;
import dexter.banking.commandbus.CommandHandler;
import dexter.banking.booktransfers.core.domain.shared.config.CommandProcessingContext;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

@Component
@RequiredArgsConstructor
@Slf4j
public class SubmitPaymentV1CommandHandler implements CommandHandler<PaymentCommand, PaymentResult> {

    private final CreditCardPort creditCardPort;
    private final DepositPort depositPort;
    private final LimitPort limitPort;
    private final PaymentRepositoryPort paymentRepository;
    private final EventDispatcherPort eventDispatcher;
    private final BusinessPolicyFactory policyFactory;
    @Override
    public boolean matches(PaymentCommand command) {
        return command.getVersion() == ApiVersion.V1;
    }

    @Override
    @Transactional
    public PaymentResult handle(PaymentCommand command) {
        log.info(" [V1] Starting procedural transaction for Command: {}", command.getTransactionReference());
        JourneySpecification spec = CommandProcessingContextHolder.getContext()
                .map(CommandProcessingContext::getJourneySpecification)
                .orElseThrow(() -> new IllegalStateException("JourneySpecification not found in context"));
        BusinessPolicy policy = policyFactory.create(spec);

        UUID transactionId = UUID.randomUUID();
        String journeyName = command.getIdentifier();
        String reasonForFailure = "";

        var creationParams = new Payment.PaymentCreationParams(
                transactionId,
                command.getTransactionReference(),
                journeyName
        );
        Payment payment = Payment.startNew(creationParams, policy);
        paymentRepository.save(payment);
        try {
            performLimitEarmark(command, payment);
            performDebitLeg(command, payment);
            performCreditLeg(command, payment);
        } catch (Exception e) {
            log.error(" [V1] Procedural transaction FAILED for TXN_ID: {}. Initiating SAGA compensation...",
                    payment.getId(), e);
            reasonForFailure = Optional.of(e).map(Throwable::getMessage).orElse("Unknown error");
            compensate(payment, command);
        } finally {

            switch(payment.getState()) {
                case FUNDS_CREDITED -> payment.recordPaymentSettled(buildMetadata(command, payment));
                case LIMIT_COULD_NOT_BE_RESERVED, LIMIT_REVERSED -> payment.recordPaymentFailed(reasonForFailure, buildMetadata(command, payment));
                default -> payment.recordPaymentRemediationNeeded(reasonForFailure, buildMetadata(command, payment));
            }

            paymentRepository.update(payment);
            eventDispatcher.dispatch(payment.pullDomainEvents());
        }

        log.info(" [V1] Procedural transaction finished for TXN_ID: {}. Final state: {}",
                payment.getId(), payment.getState());
        return PaymentResult.from(payment);
    }

    private void performCreditLeg(PaymentCommand command, Payment payment) {
        var request = new CreditCardPort.SubmitCreditCardPaymentRequest(payment.getId(), command.getCardNumber());
        CreditLegResult creditResult = creditCardPort.submitCreditCardPayment(request);
        payment.recordCredit(creditResult, buildMetadata(command, payment));
        paymentRepository.update(payment);

        if (creditResult.status() == CreditLegResult.CreditLegStatus.FAILED) {
            throw new StepFailedException("Credit Leg failed");
        }

    }

    private void performDebitLeg(PaymentCommand command, Payment payment) {
        var request = new DepositPort.SubmitDepositRequest(payment.getId(), command.getAccountNumber());
        DebitLegResult debitResult = depositPort.submitDeposit(request);
        payment.recordDebit(debitResult, buildMetadata(command, payment));
        paymentRepository.update(payment);

        if (debitResult.status() == DebitLegResult.DebitLegStatus.FAILED) {
            throw new StepFailedException("Debit Leg failed");
        }
    }

    private void performLimitEarmark(PaymentCommand command, Payment payment) {
        var request = new LimitPort.EarmarkLimitRequest(payment.getId(), command.getLimitType());
        LimitEarmarkResult limitResult = limitPort.earmarkLimit(request);
        payment.recordLimitEarmark(limitResult, buildMetadata(command, payment));
        paymentRepository.update(payment);

        if (limitResult.status() == LimitEarmarkResult.LimitEarmarkStatus.FAILED) {
            throw new StepFailedException("Limit Earmark failed");
        }
    }

    private void compensate(Payment payment, PaymentCommand command) {
        switch (payment.getState()) {
            case FUNDS_COULD_NOT_BE_CREDITED:
                compensateDebitLeg(payment, command);
                break;
            case FUNDS_COULD_NOT_BE_DEBITED:
                compensateLimitEarmark(payment, command);
                break;
            default:
                log.warn("  [COMPENSATION] Failure occurred at state {}. No compensation needed.", payment.getState());
                break;
        }
    }

    private void compensateDebitLeg(Payment payment, PaymentCommand command) {
        log.warn("  [COMPENSATION] Reversing Debit Leg for TXN_ID: {}...", payment.getId());
        try {
            var request = new DepositPort.SubmitDepositReversalRequest(payment.getId(), payment.getDebitLegResult().depositId());
            DebitLegResult reversalResult = depositPort.submitDepositReversal(request);

            payment.recordDebitReversal(reversalResult, buildMetadata(command, payment));
            paymentRepository.update(payment);

            if (reversalResult.status() == DebitLegResult.DebitLegStatus.REVERSAL_SUCCESSFUL) {
                log.info("  [COMPENSATION] Debit leg reversed successfully. Compensation saga in progress.");
                compensateLimitEarmark(payment, command);
            } else {
                log.error("  [COMPENSATION] FATAL: Reversing Debit Leg FAILED. Manual intervention required.");
            }

        } catch (Exception e) {
            log.error("  [COMPENSATION] FATAL: Reversing Debit Leg FAILED. Manual intervention required.", e);
            payment.recordDebitReversal(new DebitLegResult(null, DebitLegResult.DebitLegStatus.REVERSAL_FAILED), buildMetadata(command, payment));
            paymentRepository.update(payment);
        }
    }

    private void compensateLimitEarmark(Payment payment, PaymentCommand command) {
        log.warn("  [COMPENSATION] Reversing Limit Earmark for TXN_ID: {}...", payment.getId());
        try {
            var request = new LimitPort.ReverseLimitEarmarkRequest(payment.getId(), payment.getLimitEarmarkResult().limitId());
            LimitEarmarkResult reversalResult = limitPort.reverseLimitEarmark(request);
            payment.recordLimitReversal(reversalResult, buildMetadata(command, payment));
        } catch (Exception e) {
            log.error("  [COMPENSATION] FATAL: Reversing Limit Earmark FAILED. Manual intervention required.", e);
            payment.recordLimitReversal(new LimitEarmarkResult(null, LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_FAILED), buildMetadata(command, payment));
        } finally {
            paymentRepository.update(payment);
        }
    }

    private Map<String, Object> buildMetadata(PaymentCommand command, Payment payment) {
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("transactionReference", payment.getTransactionReference());
        return metadata;
    }

    private static class StepFailedException extends RuntimeException {
        public StepFailedException(String message) {
            super(message);
        }
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/SubmitPaymentV3CommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command;

import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.component.HybridContextMapper;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.PaymentResult;
import dexter.banking.booktransfers.core.domain.shared.config.CommandProcessingContextHolder;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import dexter.banking.booktransfers.core.port.out.CustomerPort;
import dexter.banking.booktransfers.core.port.out.EventDispatcherPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.commandbus.CommandHandler;
import dexter.banking.statemachine.StateMachineFactory;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Component
@RequiredArgsConstructor
public class SubmitPaymentV3CommandHandler implements CommandHandler<HighValuePaymentCommand, PaymentResult> {

    @Qualifier("v3TransactionFsmFactory")
    private final StateMachineFactory<ProcessStateV3, ProcessEventV3, HybridTransactionContext> stateMachineFactory;
    private final PaymentRepositoryPort paymentRepository;
    private final EventDispatcherPort eventDispatcher;
    private final BusinessPolicyFactory policyFactory;
    private final CustomerPort customerPort;
    private final HybridContextMapper contextMapper;

    @Override
    @Transactional
    public PaymentResult handle(HighValuePaymentCommand command) {
        if (!customerPort.isCustomerValid(command.getRelId())) {
            throw new IllegalArgumentException("Customer is not valid");
        }

        var spec = CommandProcessingContextHolder.getContext()
                .orElseThrow(() -> new IllegalStateException("JourneySpecification not found in context")).getJourneySpecification();
        BusinessPolicy policy = policyFactory.create(spec);

        UUID transactionId = UUID.randomUUID();
        String journeyName = command.getIdentifier();

        var creationParams = new Payment.PaymentCreationParams(
                transactionId,
                command.getTransactionReference(),
                journeyName
        );
        Payment payment = Payment.startNew(creationParams, policy);
        paymentRepository.save(payment);

        var context = contextMapper.toNewContext(payment.getId(), command);
        var stateMachine = stateMachineFactory.acquireStateMachine(context);
        stateMachine.fire(ProcessEventV3.SUBMIT);

        eventDispatcher.dispatch(payment.pullDomainEvents());
        return PaymentResult.from(payment);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/command/SyncPaymentV2CommandHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.command;

import dexter.banking.booktransfers.core.application.payment.orchestration.sync.component.TransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessState;
import dexter.banking.booktransfers.core.domain.payment.ApiVersion;
import dexter.banking.booktransfers.core.domain.payment.ModeOfTransfer;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.PaymentResult;
import dexter.banking.booktransfers.core.domain.shared.config.CommandProcessingContextHolder;
import dexter.banking.booktransfers.core.domain.shared.config.JourneySpecification;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import dexter.banking.booktransfers.core.port.out.EventDispatcherPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.commandbus.CommandHandler;
import dexter.banking.statemachine.StateMachineFactory;
import dexter.banking.booktransfers.core.domain.shared.config.CommandProcessingContext;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Component
@RequiredArgsConstructor
public class SyncPaymentV2CommandHandler implements CommandHandler<PaymentCommand, PaymentResult> {

    private final StateMachineFactory<ProcessState, ProcessEvent, TransactionContext> stateMachineFactory;
    private final PaymentRepositoryPort paymentRepository;
    private final EventDispatcherPort eventDispatcher;
    private final BusinessPolicyFactory policyFactory;
    @Override
    public boolean matches(PaymentCommand command) {
        return command.getVersion() == ApiVersion.V2 && command.getModeOfTransfer() == ModeOfTransfer.SYNC;
    }

    @Override
    @Transactional
    public PaymentResult handle(PaymentCommand command) {
        JourneySpecification spec = CommandProcessingContextHolder.getContext()
                .map(CommandProcessingContext::getJourneySpecification)
                .orElseThrow(() -> new IllegalStateException("JourneySpecification not found in context"));
        BusinessPolicy policy = policyFactory.create(spec);

        UUID transactionId = UUID.randomUUID();
        String journeyName = command.getIdentifier();
        var creationParams = new Payment.PaymentCreationParams(
                transactionId,
                command.getTransactionReference(),
                journeyName
        );
        Payment payment = Payment.startNew(creationParams, policy);
        var context = new TransactionContext(payment, command);

        paymentRepository.save(payment);
        var stateMachine = stateMachineFactory.acquireStateMachine(context);
        stateMachine.fire(ProcessEvent.SUBMIT);

        paymentRepository.update(payment);
        eventDispatcher.dispatch(payment.pullDomainEvents());

        return PaymentResult.from(context.getPayment());
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/async/action/CreditLegAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.async.action;

import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.port.out.CreditCardPort;
import dexter.banking.booktransfers.core.port.out.TransactionLegPort;
import dexter.banking.statemachine.contract.SagaAction;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import java.util.Optional;

@Component("creditLegAction")
@RequiredArgsConstructor
public class CreditLegAction implements SagaAction<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> {

    private final TransactionLegPort transactionLegPort;

    @Override
    public Optional<AsyncProcessEvent> apply(AsyncTransactionContext context, AsyncProcessEvent event) {
        var request = new CreditCardPort.SubmitCreditCardPaymentRequest(context.getPaymentId(), context.getCardNumber());
        transactionLegPort.sendCreditCardRequest(request);
        return Optional.empty();
    }

    @Override
    public Optional<AsyncProcessEvent> compensate(AsyncTransactionContext context, AsyncProcessEvent event) {
        // No compensation for the final leg in this SAGA model.
        return Optional.empty();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/async/action/DebitLegAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.async.action;

import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.port.out.DepositPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.booktransfers.core.port.out.TransactionLegPort;
import dexter.banking.statemachine.contract.SagaAction;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component("debitLegAction")
@RequiredArgsConstructor
public class DebitLegAction implements SagaAction<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> {

    private final TransactionLegPort transactionLegPort;
    private final PaymentRepositoryPort paymentRepository;

    @Override
    public Optional<AsyncProcessEvent> apply(AsyncTransactionContext context, AsyncProcessEvent event) {
        var request = new DepositPort.SubmitDepositRequest(context.getPaymentId(), context.getAccountNumber());
        transactionLegPort.sendDepositRequest(request);
        return Optional.empty();
    }

    @Override
    public Optional<AsyncProcessEvent> compensate(AsyncTransactionContext context, AsyncProcessEvent event) {
        Payment.PaymentMemento memento = paymentRepository.findMementoById(context.getPaymentId())
                .orElseThrow(() -> new TransactionNotFoundException("Transaction not found for ID: " + context.getPaymentId()));

        var request = new DepositPort.SubmitDepositReversalRequest(
                memento.id(),
                memento.debitLegResult().depositId()
        );
        transactionLegPort.sendDepositReversalRequest(request);
        return Optional.empty();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/async/action/LimitEarmarkAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.async.action;

import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.port.out.LimitPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.booktransfers.core.port.out.TransactionLegPort;
import dexter.banking.statemachine.contract.SagaAction;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component("limitEarmarkAction")
@RequiredArgsConstructor
public class LimitEarmarkAction implements SagaAction<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> {

    private final TransactionLegPort transactionLegPort;
    private final PaymentRepositoryPort paymentRepository;


    @Override
    public Optional<AsyncProcessEvent> apply(AsyncTransactionContext context, AsyncProcessEvent event) {
        var request = new LimitPort.EarmarkLimitRequest(context.getPaymentId(), context.getLimitType());
        transactionLegPort.sendLimitManagementRequest(request);
        return Optional.empty();
    }

    @Override
    public Optional<AsyncProcessEvent> compensate(AsyncTransactionContext context, AsyncProcessEvent event) {
        Payment.PaymentMemento memento = paymentRepository.findMementoById(context.getPaymentId())
                .orElseThrow(() -> new TransactionNotFoundException("Transaction not found for ID: " + context.getPaymentId()));

        var request = new LimitPort.ReverseLimitEarmarkRequest(
                memento.id(),
                memento.limitEarmarkResult().limitId()
        );
        transactionLegPort.sendLimitReversalRequest(request);
        return Optional.empty();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/async/action/TransactionFailAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.async.action;


import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentFailedUseCase;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentParams;
import dexter.banking.statemachine.contract.Action;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.Optional;

@Component
@Slf4j
@RequiredArgsConstructor
public class TransactionFailAction implements Action<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> {
    private final ConcludePaymentFailedUseCase concludePaymentFailedUseCase;

    @Override
    public Optional<AsyncProcessEvent> execute(AsyncTransactionContext context, AsyncProcessEvent event) {
        log.info("Transaction flow for {} has reached a terminal state: {}", context.getPaymentId(), context.getCurrentState());
        var params = new ConcludePaymentParams(context.getPaymentId(), event.name(), Collections.emptyMap());
        concludePaymentFailedUseCase.handleFailure(params);
        return Optional.empty();
    }

}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/async/action/TransactionRemediationAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.async.action;


import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentParams;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentRemediationUseCase;
import dexter.banking.statemachine.contract.Action;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.Optional;

@Component
@Slf4j
@RequiredArgsConstructor
public class TransactionRemediationAction implements Action<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> {
    private final ConcludePaymentRemediationUseCase concludePaymentRemediationUseCase;
    @Override
    public Optional<AsyncProcessEvent> execute(AsyncTransactionContext context, AsyncProcessEvent event) {
        log.info("Transaction flow for {} has reached a terminal state: {}", context.getPaymentId(), context.getCurrentState());
        var params = new ConcludePaymentParams(context.getPaymentId(), event.name(), Collections.emptyMap());
        concludePaymentRemediationUseCase.handleRemediation(params);
        return Optional.empty();
    }

}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/async/action/TransactionSuccessAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.async.action;


import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentParams;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentSuccessUseCase;
import dexter.banking.statemachine.contract.Action;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

@Component
@Slf4j
@RequiredArgsConstructor
public class TransactionSuccessAction implements Action<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> {
    private final ConcludePaymentSuccessUseCase concludePaymentSuccessUseCase;
    @Override
    public Optional<AsyncProcessEvent> execute(AsyncTransactionContext context, AsyncProcessEvent event) {
        log.info("Transaction flow for {} has reached a terminal state: {}", context.getPaymentId(), context.getCurrentState());
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("webhookUrl", context.getWebhookUrl());
        metadata.put("realtime", context.getRealtime());
        var params = new ConcludePaymentParams(context.getPaymentId(), null, metadata);
        concludePaymentSuccessUseCase.handleSuccess(params);
        return Optional.empty();
    }

}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/async/AsyncStateMachineConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.async;


import dexter.banking.booktransfers.core.application.payment.orchestration.async.action.TransactionFailAction;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.action.TransactionRemediationAction;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.action.TransactionSuccessAction;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.AsyncTransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.component.TransactionStateMachinePersister;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.statemachine.StateMachineBuilder;
import dexter.banking.statemachine.StateMachineConfig;
import dexter.banking.statemachine.StateMachineFactory;
import dexter.banking.statemachine.contract.SagaAction;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.EnumSet;

@Configuration
@RequiredArgsConstructor
public class AsyncStateMachineConfig {

    private final TransactionStateMachinePersister persister;

    // Correctly qualify the specific SagaAction beans.
    // The generic types must match what the builder expects.
    private final SagaAction<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> limitEarmarkAction;

    private final SagaAction<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> debitLegAction;

    private final SagaAction<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> creditLegAction;

    private final TransactionRemediationAction transactionRemediationAction;
    private final TransactionSuccessAction transactionSuccessAction;
    private final TransactionFailAction transactionFailAction;


    @Bean("asyncPaymentStateMachineConfig")
    public StateMachineConfig<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> paymentStateMachineConfig() {
        return StateMachineBuilder.<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext>newBuilder()
                .states(EnumSet.allOf(AsyncProcessState.class))
                .initial(AsyncProcessState.NEW)
                .end(AsyncProcessState.PROCESS_FAILED)
                .end(AsyncProcessState.PROCESS_SETTLED)
                .end(AsyncProcessState.REMEDIATION_REQUIRED)
                .withPersister(persister)
            // --- Happy Path ---
            .from(AsyncProcessState.NEW).on(AsyncProcessEvent.SUBMIT)
                .to(AsyncProcessState.EARMARKING_LIMIT)
                .withAction(limitEarmarkAction::apply)
                .add()
            .from(AsyncProcessState.EARMARKING_LIMIT).on(AsyncProcessEvent.LIMIT_EARMARK_SUCCEEDED)
                .to(AsyncProcessState.DEBITING_FUNDS)
                .withAction(debitLegAction::apply)
                .add()
            .from(AsyncProcessState.DEBITING_FUNDS).on(AsyncProcessEvent.DEBIT_LEG_SUCCEEDED)
                .to(AsyncProcessState.CREDITING_FUNDS)
                .withAction(creditLegAction::apply)
                .add()
            .from(AsyncProcessState.CREDITING_FUNDS).on(AsyncProcessEvent.CREDIT_LEG_SUCCEEDED)
                .to(AsyncProcessState.PROCESS_SETTLED)
                .withAction(transactionSuccessAction)
                .add()

            // --- Compensation Path ---
            .from(AsyncProcessState.CREDITING_FUNDS).on(AsyncProcessEvent.CREDIT_LEG_FAILED)
                .to(AsyncProcessState.REVERSING_DEBIT)
                .withAction(debitLegAction::compensate)
                .add()
            .from(AsyncProcessState.DEBITING_FUNDS).on(AsyncProcessEvent.DEBIT_LEG_FAILED)
                .to(AsyncProcessState.REVERSING_LIMIT_EARMARK)
                .withAction(limitEarmarkAction::compensate)
                .add()
            .from(AsyncProcessState.EARMARKING_LIMIT).on(AsyncProcessEvent.LIMIT_EARMARK_FAILED)
                .to(AsyncProcessState.PROCESS_FAILED)
                .withAction(transactionFailAction)
                .add()
            .from(AsyncProcessState.REVERSING_DEBIT).on(AsyncProcessEvent.DEBIT_LEG_REVERSAL_SUCCEEDED)
                .to(AsyncProcessState.REVERSING_LIMIT_EARMARK)
                .withAction(limitEarmarkAction::compensate)
                .add()
            .from(AsyncProcessState.REVERSING_LIMIT_EARMARK).on(AsyncProcessEvent.LIMIT_EARMARK_REVERSAL_SUCCEEDED)
                .to(AsyncProcessState.PROCESS_FAILED)
                .withAction(transactionFailAction)
                .add()

            // --- Remediation Path ---
            .from(AsyncProcessState.REVERSING_DEBIT).on(AsyncProcessEvent.DEBIT_LEG_REVERSAL_FAILED)
                .to(AsyncProcessState.REMEDIATION_REQUIRED)
                .withAction(transactionRemediationAction)
                .add()
            .from(AsyncProcessState.REVERSING_LIMIT_EARMARK).on(AsyncProcessEvent.LIMIT_EARMARK_REVERSAL_FAILED)
                .to(AsyncProcessState.REMEDIATION_REQUIRED)
                .withAction(transactionRemediationAction)
                .add()
            .build();
    }

    @Bean("asyncTransactionFsmFactory")
    public StateMachineFactory<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> transactionFsmFactory(
            @Qualifier("asyncPaymentStateMachineConfig") StateMachineConfig<AsyncProcessState, AsyncProcessEvent, AsyncTransactionContext> config) {
        return new StateMachineFactory<>(config);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/async/component/AsyncTransactionContext.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.async.component;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.domain.payment.ApiVersion;
import dexter.banking.booktransfers.core.domain.payment.ModeOfTransfer;
import dexter.banking.statemachine.contract.StateMachineContext;
import lombok.Getter;

import java.util.UUID;

/**
 * A lean, serializable context object specifically for the asynchronous state machine.
 * It contains only flattened, persistable data, not live domain objects, making it stable for persistence.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@Getter
public class AsyncTransactionContext implements StateMachineContext<AsyncProcessState> {

    private final UUID paymentId;
    private AsyncProcessState currentState;

    // --- Flattened PaymentCommand fields ---
    private final UUID idempotencyKey;
    private final String transactionReference;
    private final String limitType;
    private final String accountNumber;
    private final String cardNumber;
    private final String webhookUrl;
    private final String realtime;
    private final ModeOfTransfer modeOfTransfer;
    private final ApiVersion version;


    @JsonCreator
    public AsyncTransactionContext(
            @JsonProperty("paymentId") UUID paymentId,
            @JsonProperty("currentState") AsyncProcessState currentState,
            @JsonProperty("idempotencyKey") UUID idempotencyKey,
            @JsonProperty("transactionReference") String transactionReference,
            @JsonProperty("limitType") String limitType,
            @JsonProperty("accountNumber") String accountNumber,
            @JsonProperty("cardNumber") String cardNumber,
            @JsonProperty("webhookUrl") String webhookUrl,
            @JsonProperty("realtime") String realtime,
            @JsonProperty("modeOfTransfer") ModeOfTransfer modeOfTransfer,
            @JsonProperty("version") ApiVersion version
    ) {
        this.paymentId = paymentId;
        this.currentState = currentState;
        this.idempotencyKey = idempotencyKey;
        this.transactionReference = transactionReference;
        this.limitType = limitType;
        this.accountNumber = accountNumber;
        this.cardNumber = cardNumber;
        this.webhookUrl = webhookUrl;
        this.realtime = realtime;
        this.modeOfTransfer = modeOfTransfer;
        this.version = version;
    }

    @Override
    public AsyncProcessState getCurrentState() {
        return this.currentState;
    }

    @Override
    public void setCurrentState(AsyncProcessState newState) {
        this.currentState = newState;
    }

    @Override
    public String getId() {
        return paymentId.toString();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/async/component/OrchestrationContextMapper.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.async.component;

import dexter.banking.booktransfers.core.application.payment.command.PaymentCommand;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import org.springframework.stereotype.Component;

import java.util.UUID;
/**
 * An Anti-Corruption Layer (ACL) that translates between the application-layer
 * PaymentCommand and the infrastructure-layer, persistable AsyncTransactionContext.
 */
@Component
public class OrchestrationContextMapper {

    /**
     * Flattens a PaymentCommand into a new AsyncTransactionContext for persistence.
     * @param paymentId The ID of the payment aggregate.
     * @param command The incoming command.
     * @return A new, self-contained AsyncTransactionContext.
     */
    public AsyncTransactionContext toNewContext(UUID paymentId, PaymentCommand command) {
        return new AsyncTransactionContext(
                paymentId,
                AsyncProcessState.NEW,
                command.getIdempotencyKey(),
                command.getTransactionReference(),
                command.getLimitType(),
                command.getAccountNumber(),
                command.getCardNumber(),
                command.getWebhookUrl(),
                command.getRealtime(),
                command.getModeOfTransfer(),
                command.getVersion()
        );
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/async/component/TransactionStateMachinePersister.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.async.component;


import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import dexter.banking.booktransfers.core.application.payment.orchestration.async.model.AsyncProcessState;
import dexter.banking.booktransfers.core.port.out.OrchestrationContextRepositoryPort;
import dexter.banking.statemachine.contract.StateMachinePersister;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.Optional;
import java.util.UUID;

@Component
@RequiredArgsConstructor
@Slf4j
public class TransactionStateMachinePersister implements StateMachinePersister<AsyncProcessState, AsyncTransactionContext> {

    private final OrchestrationContextRepositoryPort contextRepository;
    private final ObjectMapper objectMapper;

    @Override
    public void saveContext(AsyncTransactionContext context) {
        try {
            byte[] contextBytes = objectMapper.writeValueAsBytes(context);
            contextRepository.save(context.getPaymentId(), contextBytes);
            log.debug("Successfully persisted context for transactionId: {}", context.getId());
        } catch (JsonProcessingException e) {
            log.error("FATAL: Failed to serialize context for transactionId: {}", context.getId(), e);
            throw new RuntimeException("Failed to serialize context", e);
        }
    }

    @Override
    public Optional<AsyncTransactionContext> findContextById(String id) {
        return contextRepository.findById(UUID.fromString(id))
            .flatMap(contextBytes -> {
                try {
                    log.debug("Found context data for transactionId: {}. Deserializing...", id);
                    return Optional.of(objectMapper.readValue(contextBytes, AsyncTransactionContext.class));
                } catch (IOException e) {
                    log.error("FATAL: Failed to deserialize context for transactionId: {}", id, e);
                    return Optional.empty();
                }
            });
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/async/model/AsyncProcessEvent.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.async.model;

/**
 * Defines the events that can trigger state transitions in the orchestration process.
 * This is an application-level concept, distinct from the domain's events.
 */
public enum AsyncProcessEvent {
    SUBMIT,

    // Action Outcome Observations
    LIMIT_EARMARK_SUCCEEDED,
    LIMIT_EARMARK_FAILED,

    DEBIT_LEG_SUCCEEDED,
    DEBIT_LEG_FAILED,

    CREDIT_LEG_SUCCEEDED,
    CREDIT_LEG_FAILED,

    DEBIT_LEG_REVERSAL_SUCCEEDED,
    DEBIT_LEG_REVERSAL_FAILED,

    LIMIT_EARMARK_REVERSAL_SUCCEEDED,
    LIMIT_EARMARK_REVERSAL_FAILED,
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/async/model/AsyncProcessState.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.async.model;

/**
 * Defines the possible states a transaction orchestration can be in during its lifecycle.
 * This is an application-level concept, representing workflow steps, and is
 * completely separate from the domain's PaymentState.
 */
public enum AsyncProcessState {
    NEW,
    EARMARKING_LIMIT,
    DEBITING_FUNDS,
    CREDITING_FUNDS,
    REVERSING_DEBIT,
    REVERSING_LIMIT_EARMARK,

    // Terminal States
    REMEDIATION_REQUIRED,
    PROCESS_FAILED,
    PROCESS_SETTLED,
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/action/AsyncCreditLegAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.action;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.port.out.CreditCardPort;
import dexter.banking.booktransfers.core.port.out.TransactionLegPort;
import dexter.banking.statemachine.contract.SagaAction;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;
@Component
@RequiredArgsConstructor
public class AsyncCreditLegAction implements SagaAction<ProcessStateV3, ProcessEventV3, HybridTransactionContext> {
    private final TransactionLegPort transactionLegPort;
    @Override
    public Optional<ProcessEventV3> apply(HybridTransactionContext context, ProcessEventV3 event) {
        var request = new CreditCardPort.SubmitCreditCardPaymentRequest(context.getPaymentId(), context.getCardNumber());
        transactionLegPort.sendCreditCardRequest(request);
        return Optional.empty(); // Pause FSM to await JMS callback
    }

    @Override
    public Optional<ProcessEventV3> compensate(HybridTransactionContext context, ProcessEventV3 event) {
        return Optional.empty(); // No compensation for the final leg
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/action/AsyncDebitLegAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.action;

import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.port.out.DepositPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.booktransfers.core.port.out.TransactionLegPort;
import dexter.banking.statemachine.contract.SagaAction;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;
@Component
@RequiredArgsConstructor
public class AsyncDebitLegAction implements SagaAction<ProcessStateV3, ProcessEventV3, HybridTransactionContext> {
    private final TransactionLegPort transactionLegPort;
    private final PaymentRepositoryPort paymentRepository;

    @Override
    public Optional<ProcessEventV3> apply(HybridTransactionContext context, ProcessEventV3 event) {
        var request = new DepositPort.SubmitDepositRequest(context.getPaymentId(), context.getAccountNumber());
        transactionLegPort.sendDepositRequest(request);
        return Optional.empty();
    }

    @Override
    public Optional<ProcessEventV3> compensate(HybridTransactionContext context, ProcessEventV3 event) {
        Payment.PaymentMemento memento = paymentRepository.findMementoById(context.getPaymentId())
                .orElseThrow(() -> new TransactionNotFoundException("Transaction not found for ID: " + context.getPaymentId()));

        var request = new DepositPort.SubmitDepositReversalRequest(
                memento.id(),
                memento.debitLegResult().depositId()
        );
        transactionLegPort.sendDepositReversalRequest(request);
        return Optional.empty();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/action/ComplianceDecisionAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.action;

import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.domain.shared.config.JourneySpecification;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import dexter.banking.booktransfers.core.port.out.ConfigurationPort;
import dexter.banking.booktransfers.core.port.out.EventDispatcherPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.statemachine.contract.Action;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.Collections;
import java.util.Optional;
import java.util.UUID;

@Component
@RequiredArgsConstructor
public class ComplianceDecisionAction implements Action<ProcessStateV3, ProcessEventV3, HybridTransactionContext> {

    private final ConfigurationPort configurationPort;
    private final PaymentRepositoryPort paymentRepository;
    private final BusinessPolicyFactory policyFactory;
    private final EventDispatcherPort eventDispatcher;

    @Override
    @Transactional
    public Optional<ProcessEventV3> execute(HybridTransactionContext context, ProcessEventV3 event) {
        Payment payment = rehydratePayment(context);
        JourneySpecification journeySpec = configurationPort.findForJourney(payment.getJourneyName())
                .orElseThrow(() -> new IllegalStateException("Journey specification not found for: " + payment.getJourneyName()));

        BigDecimal complianceThreshold = journeySpec.complianceThreshold()
                .orElseThrow(() -> new IllegalStateException("Compliance threshold is not configured for this journey."));

        BigDecimal amount = context.getTransactionAmount().amount();

        if (amount.compareTo(complianceThreshold) >= 0) {
            payment.flagForComplianceCheck(Collections.emptyMap());
            paymentRepository.update(payment);

            eventDispatcher.dispatch(payment.pullDomainEvents());
            return Optional.of(ProcessEventV3.COMPLIANCE_PENDING);
        } else {
            paymentRepository.update(payment);
            return Optional.of(ProcessEventV3.COMPLIANCE_NOT_REQUIRED);
        }
    }

    private Payment rehydratePayment(HybridTransactionContext context) {
        UUID transactionId = context.getPaymentId();
        Payment.PaymentMemento memento = paymentRepository.findMementoById(transactionId)
                .orElseThrow(() -> new TransactionNotFoundException("Transaction not found for ID: " + transactionId));
        BusinessPolicy policy = configurationPort
                .findForJourney(memento.journeyName())
                .map(policyFactory::create)
                .orElseThrow(() -> new IllegalStateException("No journey configured for identifier: " + memento.journeyName()));
        return Payment.rehydrate(memento, policy);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/action/HybridTransactionFailAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.action;


import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentFailedUseCase;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentParams;
import dexter.banking.statemachine.contract.Action;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.Optional;

@Component
@Slf4j
@RequiredArgsConstructor
public class HybridTransactionFailAction implements Action<ProcessStateV3, ProcessEventV3, HybridTransactionContext> {
    private final ConcludePaymentFailedUseCase concludePaymentFailedUseCase;

    @Override
    public Optional<ProcessEventV3> execute(HybridTransactionContext context, ProcessEventV3 event) {
        log.info("Transaction flow for {} has reached a terminal state: {}", context.getPaymentId(), context.getCurrentState());
        var params = new ConcludePaymentParams(context.getPaymentId(), event.name(), Collections.emptyMap());
        concludePaymentFailedUseCase.handleFailure(params);
        return Optional.empty();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/action/HybridTransactionRemediationAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.action;


import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentParams;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentRemediationUseCase;
import dexter.banking.statemachine.contract.Action;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.Optional;

@Component
@Slf4j
@RequiredArgsConstructor
public class HybridTransactionRemediationAction implements Action<ProcessStateV3, ProcessEventV3, HybridTransactionContext> {
    private final ConcludePaymentRemediationUseCase concludePaymentRemediationUseCase;

    @Override
    public Optional<ProcessEventV3> execute(HybridTransactionContext context, ProcessEventV3 event) {
        log.info("Transaction flow for {} has reached a terminal state: {}", context.getPaymentId(), context.getCurrentState());
        var params = new ConcludePaymentParams(context.getPaymentId(), event.name(), Collections.emptyMap());
        concludePaymentRemediationUseCase.handleRemediation(params);
        return Optional.empty();
    }

}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/action/HybridTransactionSuccessAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.action;


import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentParams;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentSuccessUseCase;
import dexter.banking.statemachine.contract.Action;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.Optional;

@Component
@Slf4j
@RequiredArgsConstructor
public class HybridTransactionSuccessAction implements Action<ProcessStateV3, ProcessEventV3, HybridTransactionContext> {
    private final ConcludePaymentSuccessUseCase concludePaymentSuccessUseCase;

    @Override
    public Optional<ProcessEventV3> execute(HybridTransactionContext context, ProcessEventV3 event) {
        log.info("Transaction flow for {} has reached a terminal state: {}", context.getPaymentId(), context.getCurrentState());
        var params = new ConcludePaymentParams(context.getPaymentId(), null, Collections.emptyMap());
        concludePaymentSuccessUseCase.handleSuccess(params);
        return Optional.empty();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/action/SyncLimitCheckAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.action;

import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import dexter.banking.booktransfers.core.port.out.ConfigurationPort;
import dexter.banking.booktransfers.core.port.out.LimitPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.statemachine.contract.SagaAction;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.Optional;
import java.util.UUID;

@Component
@RequiredArgsConstructor
@Slf4j
public class SyncLimitCheckAction implements SagaAction<ProcessStateV3, ProcessEventV3, HybridTransactionContext> {

    private final LimitPort limitPort;
    private final PaymentRepositoryPort paymentRepository;
    private final ConfigurationPort configurationPort;
    private final BusinessPolicyFactory policyFactory;
    @Override
    @Transactional
    public Optional<ProcessEventV3> apply(HybridTransactionContext context, ProcessEventV3 event) {
        Payment payment = rehydratePayment(context);
        try {
            var request = new LimitPort.EarmarkLimitRequest(context.getPaymentId(), context.getLimitType());
            LimitEarmarkResult result = limitPort.earmarkLimit(request);
            payment.recordLimitEarmark(result, Collections.emptyMap());

            if (result.status() == LimitEarmarkResult.LimitEarmarkStatus.SUCCESSFUL) {
                paymentRepository.update(payment);
                return Optional.of(ProcessEventV3.LIMIT_APPROVED);
            } else {
                paymentRepository.update(payment);
                return Optional.of(ProcessEventV3.LIMIT_REJECTED);
            }
        } catch (Exception e) {
            log.error("V3 Sync Limit Check failed with exception", e);
            payment.recordLimitEarmark(new LimitEarmarkResult(null, LimitEarmarkResult.LimitEarmarkStatus.FAILED), Collections.emptyMap());
            paymentRepository.update(payment);
            return Optional.of(ProcessEventV3.LIMIT_REJECTED);
        }
    }

    @Override
    @Transactional
    public Optional<ProcessEventV3> compensate(HybridTransactionContext context, ProcessEventV3 event) {
        Payment payment = rehydratePayment(context);
        try {
            var request = new LimitPort.ReverseLimitEarmarkRequest(payment.getId(), payment.getLimitEarmarkResult().limitId());
            LimitEarmarkResult result = limitPort.reverseLimitEarmark(request);
            payment.recordLimitReversal(result, Collections.emptyMap());
            paymentRepository.update(payment);
            if (result.status() == LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_SUCCESSFUL) {
                return Optional.of(ProcessEventV3.LIMIT_EARMARK_REVERSAL_SUCCEEDED);
            } else {
                return Optional.of(ProcessEventV3.LIMIT_EARMARK_REVERSAL_FAILED);
            }
        } catch (Exception e) {
            log.error("V3 Sync Limit Earmark compensation failed with exception", e);
            payment.recordLimitReversal(new LimitEarmarkResult(payment.getLimitEarmarkResult().limitId(), LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_FAILED), Collections.emptyMap());
            paymentRepository.update(payment);
            return Optional.of(ProcessEventV3.LIMIT_EARMARK_REVERSAL_FAILED);
        }
    }

    private Payment rehydratePayment(HybridTransactionContext context) {
        UUID transactionId = context.getPaymentId();
        Payment.PaymentMemento memento = paymentRepository.findMementoById(transactionId)
                .orElseThrow(() -> new TransactionNotFoundException("Transaction not found for ID: " + transactionId));
        BusinessPolicy policy = configurationPort
                .findForJourney(memento.journeyName())
                .map(policyFactory::create)
                .orElseThrow(() -> new IllegalStateException("No journey configured for identifier: " + memento.journeyName()));
        return Payment.rehydrate(memento, policy);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/action/TransactionCompleteActionV3.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.action;

import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import dexter.banking.booktransfers.core.port.out.ConfigurationPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import dexter.banking.statemachine.contract.Action;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.Optional;

@Component
@Slf4j
@RequiredArgsConstructor
public class TransactionCompleteActionV3 implements Action<ProcessStateV3, ProcessEventV3, HybridTransactionContext> {

    private final PaymentRepositoryPort paymentRepository;
    private final ConfigurationPort configurationPort;
    private final BusinessPolicyFactory policyFactory;

    @Override
    @Transactional
    public Optional<ProcessEventV3> execute(HybridTransactionContext context, ProcessEventV3 event) {
        log.info("V3 Transaction flow for {} has reached a terminal state: {}", context.getTransactionReference(), context.getCurrentState());

        Payment.PaymentMemento memento = paymentRepository.findMementoById(context.getPaymentId())
                .orElseThrow(() -> new TransactionNotFoundException("Payment not found: " + context.getPaymentId()));

        BusinessPolicy policy = configurationPort.findForJourney(memento.journeyName())
                .map(policyFactory::create)
                .orElseThrow(() -> new IllegalStateException("No journey configured for identifier: " + memento.journeyName()));

        Payment payment = Payment.rehydrate(memento, policy);

        switch(context.getCurrentState()) {
            case PROCESS_SETTLED -> payment.recordPaymentSettled(Collections.emptyMap());
            case PROCESS_FAILED -> payment.recordPaymentFailed(event.name(), Collections.emptyMap());
            case REMEDIATION_REQUIRED -> payment.recordPaymentRemediationNeeded(event.name(), Collections.emptyMap());
            default -> log.warn("No final action taken for state: {}", context.getCurrentState());
        }

        paymentRepository.update(payment);
        return Optional.empty();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/component/HybridContextMapper.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.component;

import dexter.banking.booktransfers.core.application.payment.command.HighValuePaymentCommand;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
public class HybridContextMapper {

    public HybridTransactionContext toNewContext(UUID paymentId, HighValuePaymentCommand command) {
        return new HybridTransactionContext(
                paymentId,
                ProcessStateV3.NEW,
                command.getIdempotencyKey(),
                command.getTransactionReference(),
                command.getRelId(),
                command.getTransactionAmount(),
                command.getLimitType(),
                command.getAccountNumber(),
                command.getCardNumber()
        );
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/model/ProcessEventV3.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model;

public enum ProcessEventV3 {
    SUBMIT,

    LIMIT_APPROVED,
    LIMIT_REJECTED,

    COMPLIANCE_PENDING,
    COMPLIANCE_NOT_REQUIRED,
    COMPLIANCE_REJECTED,

    RESUME, // Event from Compliance Saga

    DEBIT_LEG_SUCCEEDED,
    DEBIT_LEG_FAILED,

    CREDIT_LEG_SUCCEEDED,
    CREDIT_LEG_FAILED,

    DEBIT_LEG_REVERSAL_SUCCEEDED,
    DEBIT_LEG_REVERSAL_FAILED,

    LIMIT_EARMARK_REVERSAL_SUCCEEDED,
    LIMIT_EARMARK_REVERSAL_FAILED
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/model/ProcessStateV3.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model;

public enum ProcessStateV3 {
    NEW,
    EARMARKING_LIMIT, // Sync
    CHECKING_COMPLIANCE, // Sync (cascade)
    AWAITING_COMPLIANCE_APPROVAL, // PAUSE
    DEBITING_FUNDS, // Async
    CREDITING_FUNDS, // Async
    REVERSING_DEBIT, // Async
    REVERSING_LIMIT_EARMARK, // Sync

    // Terminal States
    REMEDIATION_REQUIRED,
    PROCESS_FAILED,
    PROCESS_SETTLED,
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/persistence/HybridStateMachinePersister.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.port.out.OrchestrationContextRepositoryPort;
import dexter.banking.statemachine.contract.StateMachinePersister;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.Optional;
import java.util.UUID;

@Component
@RequiredArgsConstructor
@Slf4j
public class HybridStateMachinePersister implements StateMachinePersister<ProcessStateV3, HybridTransactionContext> {
    private final OrchestrationContextRepositoryPort contextRepository;
    private final ObjectMapper objectMapper;

    @Override
    public void saveContext(HybridTransactionContext context) {
        try {
            byte[] contextBytes = objectMapper.writeValueAsBytes(context);
            contextRepository.save(context.getPaymentId(), contextBytes);
            log.debug("Successfully persisted hybrid context for transactionId: {}", context.getId());
        } catch (JsonProcessingException e) {
            log.error("FATAL: Failed to serialize hybrid context for transactionId: {}", context.getId(), e);
            throw new RuntimeException("Failed to serialize context", e);
        }
    }

    @Override
    public Optional<HybridTransactionContext> findContextById(String id) {
        return contextRepository.findById(UUID.fromString(id))
                .flatMap(contextBytes -> {
                    try {
                        log.debug("Found hybrid context data for transactionId: {}. Deserializing...", id);
                        return Optional.of(objectMapper.readValue(contextBytes, HybridTransactionContext.class));
                    } catch (IOException e) {
                        log.error("FATAL: Failed to deserialize hybrid context for transactionId: {}", id, e);
                        return Optional.empty();
                    }
                });
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/persistence/HybridTransactionContext.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.domain.payment.valueobject.RelId;
import dexter.banking.booktransfers.core.domain.payment.valueobject.TransactionAmount;
import dexter.banking.statemachine.contract.StateMachineContext;
import lombok.Getter;

import java.util.UUID;

@JsonIgnoreProperties(ignoreUnknown = true)
@Getter
public class HybridTransactionContext implements StateMachineContext<ProcessStateV3> {

    private final UUID paymentId;
    private ProcessStateV3 currentState;

    // --- Flattened HighValuePaymentCommand fields ---
    private final UUID idempotencyKey;
    private final String transactionReference;
    private final RelId relId;
    private final TransactionAmount transactionAmount;
    private final String limitType;
    private final String accountNumber;
    private final String cardNumber;

    @JsonCreator
    public HybridTransactionContext(
            @JsonProperty("paymentId") UUID paymentId,
            @JsonProperty("currentState") ProcessStateV3 currentState,
            @JsonProperty("idempotencyKey") UUID idempotencyKey,
            @JsonProperty("transactionReference") String transactionReference,
            @JsonProperty("relId") RelId relId,
            @JsonProperty("transactionAmount") TransactionAmount transactionAmount,
            @JsonProperty("limitType") String limitType,
            @JsonProperty("accountNumber") String accountNumber,
            @JsonProperty("cardNumber") String cardNumber
    ) {
        this.paymentId = paymentId;
        this.currentState = currentState;
        this.idempotencyKey = idempotencyKey;
        this.transactionReference = transactionReference;
        this.relId = relId;
        this.transactionAmount = transactionAmount;
        this.limitType = limitType;
        this.accountNumber = accountNumber;
        this.cardNumber = cardNumber;
    }

    @Override
    public ProcessStateV3 getCurrentState() {
        return this.currentState;
    }

    @Override
    public void setCurrentState(ProcessStateV3 newState) {
        this.currentState = newState;
    }

    @Override
    public String getId() {
        return paymentId.toString();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/hybrid/V3StateMachineConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.hybrid;

import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.action.*;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridStateMachinePersister;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.statemachine.StateMachineBuilder;
import dexter.banking.statemachine.StateMachineConfig;
import dexter.banking.statemachine.StateMachineFactory;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.EnumSet;

@Configuration
@RequiredArgsConstructor
public class V3StateMachineConfig {

    private final SyncLimitCheckAction syncLimitCheckAction;
    private final ComplianceDecisionAction complianceDecisionAction;
    private final AsyncDebitLegAction asyncDebitLegAction;
    private final AsyncCreditLegAction asyncCreditLegAction;
    private final HybridTransactionRemediationAction remediationAction;
    private final HybridTransactionSuccessAction successAction;
    private final HybridTransactionFailAction failAction;
    private final HybridStateMachinePersister persister;

    @Bean("v3PaymentStateMachineConfig")
    public StateMachineConfig<ProcessStateV3, ProcessEventV3, HybridTransactionContext> paymentStateMachineConfig() {
        return StateMachineBuilder.<ProcessStateV3, ProcessEventV3, HybridTransactionContext>newBuilder()
                .states(EnumSet.allOf(ProcessStateV3.class))
                .initial(ProcessStateV3.NEW)
                .end(ProcessStateV3.PROCESS_FAILED)
                .end(ProcessStateV3.PROCESS_SETTLED)
                .end(ProcessStateV3.REMEDIATION_REQUIRED)
                .withPersister(persister)

                // 1. Initial synchronous part
                .from(ProcessStateV3.NEW).on(ProcessEventV3.SUBMIT)
                .to(ProcessStateV3.EARMARKING_LIMIT)
                .withAction(syncLimitCheckAction::apply)
                .add()

                // 2. Cascade to compliance check
                .from(ProcessStateV3.EARMARKING_LIMIT).on(ProcessEventV3.LIMIT_APPROVED)
                .to(ProcessStateV3.CHECKING_COMPLIANCE)
                .withAction(complianceDecisionAction)
                .add()

                // 3. Pause for compliance or proceed to debit
                .from(ProcessStateV3.CHECKING_COMPLIANCE).on(ProcessEventV3.COMPLIANCE_NOT_REQUIRED)
                .to(ProcessStateV3.DEBITING_FUNDS)
                .withAction(asyncDebitLegAction::apply)
                .add()
                .from(ProcessStateV3.CHECKING_COMPLIANCE).on(ProcessEventV3.COMPLIANCE_PENDING)
                .to(ProcessStateV3.AWAITING_COMPLIANCE_APPROVAL)
                .add() // PAUSE

                // 4. Resume from compliance
                .from(ProcessStateV3.AWAITING_COMPLIANCE_APPROVAL).on(ProcessEventV3.RESUME)
                .to(ProcessStateV3.DEBITING_FUNDS)
                .withAction(asyncDebitLegAction::apply)
                .add()

                // 5. Async debit/credit legs
                .from(ProcessStateV3.DEBITING_FUNDS).on(ProcessEventV3.DEBIT_LEG_SUCCEEDED)
                .to(ProcessStateV3.CREDITING_FUNDS)
                .withAction(asyncCreditLegAction::apply)
                .add()
                .from(ProcessStateV3.CREDITING_FUNDS).on(ProcessEventV3.CREDIT_LEG_SUCCEEDED)
                .to(ProcessStateV3.PROCESS_SETTLED)
                .withAction(successAction)
                .add()

                // --- Compensation Path ---
                .from(ProcessStateV3.EARMARKING_LIMIT).on(ProcessEventV3.LIMIT_REJECTED)
                .to(ProcessStateV3.PROCESS_FAILED)
                .withAction(failAction)
                .add()
                .from(ProcessStateV3.AWAITING_COMPLIANCE_APPROVAL).on(ProcessEventV3.COMPLIANCE_REJECTED) // New failure path
                .to(ProcessStateV3.REVERSING_LIMIT_EARMARK)
                .withAction(syncLimitCheckAction::compensate)
                .add()
                .from(ProcessStateV3.CREDITING_FUNDS).on(ProcessEventV3.CREDIT_LEG_FAILED)
                .to(ProcessStateV3.REVERSING_DEBIT)
                .withAction(asyncDebitLegAction::compensate)
                .add()
                .from(ProcessStateV3.DEBITING_FUNDS).on(ProcessEventV3.DEBIT_LEG_FAILED)
                .to(ProcessStateV3.REVERSING_LIMIT_EARMARK)
                .withAction(syncLimitCheckAction::compensate)
                .add()
                .from(ProcessStateV3.REVERSING_DEBIT).on(ProcessEventV3.DEBIT_LEG_REVERSAL_SUCCEEDED)
                .to(ProcessStateV3.REVERSING_LIMIT_EARMARK)
                .withAction(syncLimitCheckAction::compensate)
                .add()
                .from(ProcessStateV3.REVERSING_LIMIT_EARMARK).on(ProcessEventV3.LIMIT_EARMARK_REVERSAL_SUCCEEDED)
                .to(ProcessStateV3.PROCESS_FAILED)
                .withAction(failAction)
                .add()

                // --- Remediation Path ---
                .from(ProcessStateV3.REVERSING_DEBIT).on(ProcessEventV3.DEBIT_LEG_REVERSAL_FAILED)
                .to(ProcessStateV3.REMEDIATION_REQUIRED)
                .withAction(remediationAction)
                .add()
                .from(ProcessStateV3.REVERSING_LIMIT_EARMARK).on(ProcessEventV3.LIMIT_EARMARK_REVERSAL_FAILED)
                .to(ProcessStateV3.REMEDIATION_REQUIRED)
                .withAction(remediationAction)
                .add()

                .build();
    }

    @Bean("v3TransactionFsmFactory")
    public StateMachineFactory<ProcessStateV3, ProcessEventV3, HybridTransactionContext> transactionFsmFactory(
            @Qualifier("v3PaymentStateMachineConfig") StateMachineConfig<ProcessStateV3, ProcessEventV3, HybridTransactionContext> config) {
        return new StateMachineFactory<>(config);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/sync/action/SyncCreditLegAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.sync.action;


import dexter.banking.booktransfers.core.application.payment.orchestration.sync.component.TransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessState;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.CreditLegResult;
import dexter.banking.booktransfers.core.port.out.CreditCardPort;
import dexter.banking.statemachine.contract.SagaAction;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.Optional;

@Component
@RequiredArgsConstructor
@Slf4j
public class SyncCreditLegAction implements SagaAction<ProcessState, ProcessEvent, TransactionContext> {

    private final CreditCardPort creditCardPort;
    @Override
    public Optional<ProcessEvent> apply(TransactionContext context, ProcessEvent event) {
        var payment = context.getPayment();
        try {
            var request = new CreditCardPort.SubmitCreditCardPaymentRequest(
                    payment.getId(),
                    context.getRequest().getCardNumber()
            );
            CreditLegResult result = creditCardPort.submitCreditCardPayment(request);
            payment.recordCredit(result, Collections.emptyMap());
            if (result.status() == CreditLegResult.CreditLegStatus.SUCCESSFUL) {
                return Optional.of(ProcessEvent.CREDIT_LEG_SUCCEEDED);
            } else {
                return Optional.of(ProcessEvent.CREDIT_LEG_FAILED);
            }
        } catch (Exception e) {
            log.error("Sync Credit Leg failed with exception", e);
            payment.recordCredit(new CreditLegResult(null, CreditLegResult.CreditLegStatus.FAILED), Collections.emptyMap());
            return Optional.of(ProcessEvent.CREDIT_LEG_FAILED);
        }
    }

    @Override
    public Optional<ProcessEvent> compensate(TransactionContext context, ProcessEvent event) {
        return Optional.empty();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/sync/action/SyncDebitLegAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.sync.action;


import dexter.banking.booktransfers.core.application.payment.orchestration.sync.component.TransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessState;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.booktransfers.core.port.out.DepositPort;
import dexter.banking.statemachine.contract.SagaAction;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.Optional;

@Component
@RequiredArgsConstructor
@Slf4j
public class SyncDebitLegAction implements SagaAction<ProcessState, ProcessEvent, TransactionContext> {

    private final DepositPort depositPort;
    @Override
    public Optional<ProcessEvent> apply(TransactionContext context, ProcessEvent event) {
        var payment = context.getPayment();
        try {
            var request = new DepositPort.SubmitDepositRequest(
                    payment.getId(),
                    context.getRequest().getAccountNumber()
            );
            DebitLegResult result = depositPort.submitDeposit(request);
            payment.recordDebit(result, Collections.emptyMap());
            if (result.status() == DebitLegResult.DebitLegStatus.SUCCESSFUL) {
                return Optional.of(ProcessEvent.DEBIT_LEG_SUCCEEDED);
            } else {
                return Optional.of(ProcessEvent.DEBIT_LEG_FAILED);
            }
        } catch (Exception e) {
            log.error("Sync Debit Leg failed with exception", e);
            payment.recordDebit(new DebitLegResult(null, DebitLegResult.DebitLegStatus.FAILED), Collections.emptyMap());
            return Optional.of(ProcessEvent.DEBIT_LEG_FAILED);
        }
    }

    @Override
    public Optional<ProcessEvent> compensate(TransactionContext context, ProcessEvent event) {
        var payment = context.getPayment();
        try {
            var request = new DepositPort.SubmitDepositReversalRequest(
                    payment.getId(),
                    payment.getDebitLegResult().depositId()
            );
            DebitLegResult result = depositPort.submitDepositReversal(request);
            payment.recordDebitReversal(result, Collections.emptyMap());
            if (result.status() == DebitLegResult.DebitLegStatus.REVERSAL_SUCCESSFUL) {
                return Optional.of(ProcessEvent.DEBIT_LEG_REVERSAL_SUCCEEDED);
            } else {
                return Optional.of(ProcessEvent.DEBIT_LEG_REVERSAL_FAILED);
            }
        } catch (Exception e) {
            log.error("Sync Debit Leg compensation failed with exception", e);
            payment.recordDebitReversal(new DebitLegResult(payment.getDebitLegResult().depositId(), DebitLegResult.DebitLegStatus.REVERSAL_FAILED), Collections.emptyMap());
            return Optional.of(ProcessEvent.DEBIT_LEG_REVERSAL_FAILED);
        }
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/sync/action/SyncLimitEarmarkAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.sync.action;


import dexter.banking.booktransfers.core.application.payment.orchestration.sync.component.TransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessState;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import dexter.banking.booktransfers.core.port.out.LimitPort;
import dexter.banking.statemachine.contract.SagaAction;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.Optional;

@Component
@RequiredArgsConstructor
@Slf4j
public class SyncLimitEarmarkAction implements SagaAction<ProcessState, ProcessEvent, TransactionContext> {

    private final LimitPort limitPort;
    @Override
    public Optional<ProcessEvent> apply(TransactionContext context, ProcessEvent event) {
        var payment = context.getPayment();
        try {
            var request = new LimitPort.EarmarkLimitRequest(
                    payment.getId(),
                    context.getRequest().getLimitType()
            );
            LimitEarmarkResult result = limitPort.earmarkLimit(request);
            payment.recordLimitEarmark(result, Collections.emptyMap());
            if (result.status() == LimitEarmarkResult.LimitEarmarkStatus.SUCCESSFUL) {
                return Optional.of(ProcessEvent.LIMIT_EARMARK_SUCCEEDED);
            } else {
                return Optional.of(ProcessEvent.LIMIT_EARMARK_FAILED);
            }
        } catch (Exception e) {
            log.error("Sync Limit Earmark failed with exception", e);
            payment.recordLimitEarmark(new LimitEarmarkResult(null, LimitEarmarkResult.LimitEarmarkStatus.FAILED), Collections.emptyMap());
            return Optional.of(ProcessEvent.LIMIT_EARMARK_FAILED);
        }
    }

    @Override
    public Optional<ProcessEvent> compensate(TransactionContext context, ProcessEvent event) {
        var payment = context.getPayment();
        try {
            var request = new LimitPort.ReverseLimitEarmarkRequest(
                    payment.getId(),
                    payment.getLimitEarmarkResult().limitId()
            );
            LimitEarmarkResult result = limitPort.reverseLimitEarmark(request);
            payment.recordLimitReversal(result, Collections.emptyMap());
            if (result.status() == LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_SUCCESSFUL) {
                return Optional.of(ProcessEvent.LIMIT_EARMARK_REVERSAL_SUCCEEDED);
            } else {
                return Optional.of(ProcessEvent.LIMIT_EARMARK_REVERSAL_FAILED);
            }
        } catch (Exception e) {
            log.error("Sync Limit Earmark compensation failed with exception", e);
            payment.recordLimitReversal(new LimitEarmarkResult(payment.getLimitEarmarkResult().limitId(), LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_FAILED), Collections.emptyMap());
            return Optional.of(ProcessEvent.LIMIT_EARMARK_REVERSAL_FAILED);
        }
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/sync/action/SyncTransactionCompleteAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.sync.action;

import dexter.banking.booktransfers.core.application.payment.orchestration.sync.component.TransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessState;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.statemachine.contract.Action;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

@Component
@Slf4j
public class SyncTransactionCompleteAction implements Action<ProcessState, ProcessEvent, TransactionContext> {
    @Override
    public Optional<ProcessEvent> execute(TransactionContext context, ProcessEvent event) {
        log.info("SYNC Transaction flow for {} has reached a terminal state: {}", context.getRequest().getTransactionReference(), context.getCurrentState());
        var payment = context.getPayment();

        switch(event) {
            case CREDIT_LEG_SUCCEEDED -> payment.recordPaymentSettled(buildMetadata(payment));
            case LIMIT_EARMARK_FAILED, LIMIT_EARMARK_REVERSAL_SUCCEEDED -> payment.recordPaymentFailed("", buildMetadata(payment));
            case LIMIT_EARMARK_REVERSAL_FAILED, DEBIT_LEG_REVERSAL_FAILED -> payment.recordPaymentRemediationNeeded(event.name(), buildMetadata(payment));
            default -> log.warn("No action taken for terminal event: {}", event);
        }

        return Optional.empty();
    }

    private Map<String, Object> buildMetadata(Payment payment) {
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("transactionReference", payment.getTransactionReference());
        return metadata;
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/sync/component/TransactionContext.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.sync.component;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

import dexter.banking.booktransfers.core.application.payment.command.PaymentCommand;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessState;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.statemachine.contract.StateMachineContext;
import lombok.Getter;

@Getter
public class TransactionContext implements StateMachineContext<ProcessState> {

    // The live aggregate, used by SYNC state machine actions
    private final transient Payment payment;
    // The initial request, available to all actions
    private final PaymentCommand request;

    private ProcessState currentState;

    @JsonCreator
    public TransactionContext(
            @JsonProperty("payment") Payment payment,
            @JsonProperty("request") PaymentCommand request,
            @JsonProperty("currentState") ProcessState currentState) {
        this.payment = payment;
        this.request = request;
        this.currentState = currentState;
    }

    public TransactionContext(Payment payment, PaymentCommand request) {
        this(payment, request, ProcessState.NEW);
    }


    @Override
    public ProcessState getCurrentState() {
        return this.currentState;
    }

    @Override
    public void setCurrentState(ProcessState newState) {
        this.currentState = newState;
    }

    @Override
    public String getId() {
        return payment.getId().toString();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/sync/model/ProcessEvent.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.sync.model;

/**
 * Defines the events that can trigger state transitions in the orchestration process.
 * This is an application-level concept, distinct from the domain's events.
 */
public enum ProcessEvent {
    SUBMIT,

    // Action Outcome Observations
    LIMIT_EARMARK_SUCCEEDED,
    LIMIT_EARMARK_FAILED,

    DEBIT_LEG_SUCCEEDED,
    DEBIT_LEG_FAILED,

    CREDIT_LEG_SUCCEEDED,
    CREDIT_LEG_FAILED,

    DEBIT_LEG_REVERSAL_SUCCEEDED,
    DEBIT_LEG_REVERSAL_FAILED,

    LIMIT_EARMARK_REVERSAL_SUCCEEDED,
    LIMIT_EARMARK_REVERSAL_FAILED
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/sync/model/ProcessState.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.sync.model;

/**
 * Defines the possible states a transaction orchestration can be in during its lifecycle.
 * This is an application-level concept, representing workflow steps, and is
 * completely separate from the domain's PaymentState.
 */
public enum ProcessState {
    NEW,
    EARMARKING_LIMIT,
    DEBITING_FUNDS,
    CREDITING_FUNDS,
    REVERSING_DEBIT,
    REVERSING_LIMIT_EARMARK,

    // Terminal States
    REMEDIATION_REQUIRED,
    PROCESS_FAILED,
    PROCESS_COMPLETED
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/orchestration/sync/SyncStateMachineConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.orchestration.sync;


import dexter.banking.booktransfers.core.application.payment.orchestration.sync.action.SyncCreditLegAction;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.action.SyncDebitLegAction;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.action.SyncLimitEarmarkAction;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.action.SyncTransactionCompleteAction;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.component.TransactionContext;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessEvent;
import dexter.banking.booktransfers.core.application.payment.orchestration.sync.model.ProcessState;
import dexter.banking.statemachine.StateMachineBuilder;
import dexter.banking.statemachine.StateMachineConfig;
import dexter.banking.statemachine.StateMachineFactory;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.EnumSet;

@Configuration
@RequiredArgsConstructor
public class SyncStateMachineConfig {

    private final SyncLimitEarmarkAction limitEarmarkAction;
    private final SyncDebitLegAction debitLegAction;
    private final SyncCreditLegAction creditLegAction;
    private final SyncTransactionCompleteAction transactionCompleteAction;

    @Bean("syncPaymentStateMachineConfig")
    public StateMachineConfig<ProcessState, ProcessEvent, TransactionContext> syncPaymentStateMachineConfig() {
        return StateMachineBuilder.<ProcessState, ProcessEvent, TransactionContext>newBuilder()
                .states(EnumSet.allOf(ProcessState.class))
                .initial(ProcessState.NEW)
                .end(ProcessState.PROCESS_FAILED)
                .end(ProcessState.PROCESS_COMPLETED)
                .end(ProcessState.REMEDIATION_REQUIRED)

            .from(ProcessState.NEW).on(ProcessEvent.SUBMIT)
                .to(ProcessState.EARMARKING_LIMIT)
                .withAction(limitEarmarkAction::apply)
                .add()
            .from(ProcessState.EARMARKING_LIMIT).on(ProcessEvent.LIMIT_EARMARK_SUCCEEDED)
                .to(ProcessState.DEBITING_FUNDS)
                .withAction(debitLegAction::apply)
                .add()
            .from(ProcessState.DEBITING_FUNDS).on(ProcessEvent.DEBIT_LEG_SUCCEEDED)
                .to(ProcessState.CREDITING_FUNDS)
                .withAction(creditLegAction::apply)
                .add()
            .from(ProcessState.CREDITING_FUNDS).on(ProcessEvent.CREDIT_LEG_SUCCEEDED)
                .to(ProcessState.PROCESS_COMPLETED)
                .withAction(transactionCompleteAction)
                .add()
            .from(ProcessState.CREDITING_FUNDS).on(ProcessEvent.CREDIT_LEG_FAILED)
                .to(ProcessState.REVERSING_DEBIT)
                .withAction(debitLegAction::compensate)
                .add()
            .from(ProcessState.DEBITING_FUNDS).on(ProcessEvent.DEBIT_LEG_FAILED)
                .to(ProcessState.REVERSING_LIMIT_EARMARK)
                .withAction(limitEarmarkAction::compensate)
                .add()
            .from(ProcessState.EARMARKING_LIMIT).on(ProcessEvent.LIMIT_EARMARK_FAILED)
                .to(ProcessState.PROCESS_FAILED)
                .withAction(transactionCompleteAction)
                .add()
            .from(ProcessState.REVERSING_DEBIT).on(ProcessEvent.DEBIT_LEG_REVERSAL_SUCCEEDED)
                .to(ProcessState.REVERSING_LIMIT_EARMARK)
                .withAction(limitEarmarkAction::compensate)
                .add()
            .from(ProcessState.REVERSING_LIMIT_EARMARK).on(ProcessEvent.LIMIT_EARMARK_REVERSAL_SUCCEEDED)
                .to(ProcessState.PROCESS_FAILED)
                .withAction(transactionCompleteAction)
                .add()
            .from(ProcessState.REVERSING_DEBIT).on(ProcessEvent.DEBIT_LEG_REVERSAL_FAILED)
                .to(ProcessState.REMEDIATION_REQUIRED)
                .withAction(transactionCompleteAction)
                .add()
            .from(ProcessState.REVERSING_LIMIT_EARMARK).on(ProcessEvent.LIMIT_EARMARK_REVERSAL_FAILED)
                .to(ProcessState.REMEDIATION_REQUIRED)
                .withAction(transactionCompleteAction)
                .add()
            .build();
    }

    @Bean("syncTransactionFsmFactory")
    public StateMachineFactory<ProcessState, ProcessEvent, TransactionContext> transactionFsmFactory(
            @Qualifier("syncPaymentStateMachineConfig") StateMachineConfig<ProcessState, ProcessEvent, TransactionContext> config) {
        return new StateMachineFactory<>(config);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/query/PaymentView.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.query;


import dexter.banking.booktransfers.core.domain.payment.PaymentState;
import dexter.banking.booktransfers.core.domain.payment.Status;

import java.util.UUID;

/**
 * The dedicated Read Model for payment queries.
 * This is an immutable, flat DTO containing only the data needed by query clients.
 * It has no business logic.
 */
public record PaymentView(
    UUID transactionId,
    String transactionReference,
    Status status,
    PaymentState state
) {}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/service/ConcludePaymentService.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.service;
import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.domain.shared.config.JourneySpecification;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentFailedUseCase;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentParams;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentRemediationUseCase;
import dexter.banking.booktransfers.core.port.in.payment.ConcludePaymentSuccessUseCase;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import dexter.banking.booktransfers.core.port.out.ConfigurationPort;
import dexter.banking.booktransfers.core.port.out.EventDispatcherPort;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Consumer;

@Component
@RequiredArgsConstructor
public class ConcludePaymentService implements ConcludePaymentSuccessUseCase, ConcludePaymentRemediationUseCase, ConcludePaymentFailedUseCase {
    private final PaymentRepositoryPort paymentRepository;
    private final EventDispatcherPort eventDispatcher;
    private final BusinessPolicyFactory policyFactory;
    private final ConfigurationPort configurationPort;

    @Override
    public void handleFailure(ConcludePaymentParams params) {
       concludePayment(params.transactionId(), payment -> {
          payment.recordPaymentFailed(params.reason(), buildMetadata(payment, params));
       });
    }

    @Override
    public void handleRemediation(ConcludePaymentParams params) {
        concludePayment(params.transactionId(), payment -> {
            payment.recordPaymentRemediationNeeded(params.reason(), buildMetadata(payment, params));
        });
    }

    @Override
    public void handleSuccess(ConcludePaymentParams params) {
        concludePayment(params.transactionId(), payment -> {
            payment.recordPaymentSettled(buildMetadata(payment, params));
        });
    }

    private void concludePayment(UUID transactionId, Consumer<Payment> recordPaymentAction) {
        Payment.PaymentMemento memento = paymentRepository.findMementoById(transactionId)
                .orElseThrow(() -> new TransactionNotFoundException("Transaction not found for ID: " + transactionId));
        JourneySpecification spec = configurationPort.findForJourney(memento.journeyName())
                .orElseThrow(() -> new IllegalStateException("No journey configured for identifier: " + memento.journeyName()));
        BusinessPolicy policy = policyFactory.create(spec);

        var payment = Payment.rehydrate(memento, policy);

        recordPaymentAction.accept(payment);
        paymentRepository.update(payment);
        eventDispatcher.dispatch(payment.pullDomainEvents());
    }

    private Map<String, Object> buildMetadata(Payment payment, ConcludePaymentParams params) {
        Map<String, Object> metadata = new HashMap<>(params.metadata());
        metadata.put("transactionReference", payment.getTransactionReference());
        return metadata;
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/service/FailPaymentService.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.service;

import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.port.in.payment.FailPaymentParams;
import dexter.banking.booktransfers.core.port.in.payment.FailPaymentUseCase;
import dexter.banking.statemachine.StateMachine;
import dexter.banking.statemachine.StateMachineFactory;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class FailPaymentService implements FailPaymentUseCase {

    @Qualifier("v3TransactionFsmFactory")
    private final StateMachineFactory<ProcessStateV3, ProcessEventV3, HybridTransactionContext> stateMachineFactory;
    @Override
    @Transactional
    public void fail(FailPaymentParams params) {
        StateMachine<ProcessStateV3, ProcessEventV3, HybridTransactionContext> stateMachine = stateMachineFactory.acquireStateMachine(params.paymentId().toString())
                .orElseThrow(() -> new IllegalStateException("Could not find state machine for payment ID: " + params.paymentId()));
        stateMachine.fire(ProcessEventV3.COMPLIANCE_REJECTED);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/application/payment/service/ResumePaymentService.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.application.payment.service;

import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessEventV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.model.ProcessStateV3;
import dexter.banking.booktransfers.core.application.payment.orchestration.hybrid.persistence.HybridTransactionContext;
import dexter.banking.booktransfers.core.port.in.payment.ResumePaymentParams;
import dexter.banking.booktransfers.core.port.in.payment.ResumePaymentUseCase;
import dexter.banking.statemachine.StateMachine;
import dexter.banking.statemachine.StateMachineFactory;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class ResumePaymentService implements ResumePaymentUseCase {
    @Qualifier("v3TransactionFsmFactory")
    private final StateMachineFactory<ProcessStateV3, ProcessEventV3, HybridTransactionContext> stateMachineFactory;
    @Override
    @Transactional
    public void resume(ResumePaymentParams params) {
        StateMachine<ProcessStateV3, ProcessEventV3, HybridTransactionContext> stateMachine = stateMachineFactory.acquireStateMachine(params.paymentId().toString())
                .orElseThrow(() -> new IllegalStateException("Could not find state machine for payment ID: " + params.paymentId()));
        stateMachine.fire(ProcessEventV3.RESUME);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/compliance/ComplianceCase.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.compliance;

import dexter.banking.booktransfers.core.domain.compliance.event.ComplianceCaseApproved;
import dexter.banking.booktransfers.core.domain.compliance.event.ComplianceCaseRejected;
import dexter.banking.booktransfers.core.domain.shared.primitives.AggregateRoot;
import lombok.Getter;

import java.util.UUID;

@Getter
public class ComplianceCase extends AggregateRoot<UUID> {
    private final UUID paymentId;
    private ComplianceStatus status;
    private String reason;

    private ComplianceCase(UUID id, UUID paymentId, ComplianceStatus status, String reason) {
        super(id);
        this.paymentId = paymentId;
        this.status = status;
        this.reason = reason;
    }

    public static ComplianceCase create(UUID paymentId) {
        return new ComplianceCase(UUID.randomUUID(), paymentId, ComplianceStatus.PENDING_VERIFICATION, null);
    }

    public static ComplianceCase rehydrate(UUID id, UUID paymentId, ComplianceStatus status, String reason) {
        return new ComplianceCase(id, paymentId, status, reason);
    }

    public void approve() {
        if (this.status != ComplianceStatus.PENDING_VERIFICATION) {
            throw new IllegalStateException("Cannot approve a compliance case that is not in PENDING_VERIFICATION state. Current state: " + this.status);
        }
        this.status = ComplianceStatus.APPROVED;
        this.registerEvent(new ComplianceCaseApproved(this.id, this.paymentId));
    }

    public void reject(String reason) {
        if (this.status != ComplianceStatus.PENDING_VERIFICATION) {
            throw new IllegalStateException("Cannot reject a compliance case that is not in PENDING_VERIFICATION state. Current state: " + this.status);
        }
        this.status = ComplianceStatus.REJECTED;
        this.reason = reason;
        this.registerEvent(new ComplianceCaseRejected(this.id, this.paymentId, reason));
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/compliance/ComplianceStatus.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.compliance;

public enum ComplianceStatus {
    PENDING_VERIFICATION,
    APPROVED,
    REJECTED
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/compliance/event/ComplianceCaseApproved.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.compliance.event;

import dexter.banking.booktransfers.core.domain.shared.primitives.DomainEvent;

import java.time.Instant;
import java.util.Collections;
import java.util.Map;
import java.util.UUID;

public record ComplianceCaseApproved(
        UUID eventId,
        UUID aggregateId,
        Instant occurredOn,
        UUID paymentId
) implements DomainEvent<UUID> {
    public ComplianceCaseApproved(UUID aggregateId, UUID paymentId) {
        this(UUID.randomUUID(), aggregateId, Instant.now(), paymentId);
    }

    @Override
    public Map<String, Object> metadata() {
        return Collections.emptyMap();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/compliance/event/ComplianceCaseRejected.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.compliance.event;

import dexter.banking.booktransfers.core.domain.shared.primitives.DomainEvent;

import java.time.Instant;
import java.util.Collections;
import java.util.Map;
import java.util.UUID;

public record ComplianceCaseRejected(
        UUID eventId,
        UUID aggregateId,
        Instant occurredOn,
        UUID paymentId,
        String reason
) implements DomainEvent<UUID> {
    public ComplianceCaseRejected(UUID aggregateId, UUID paymentId, String reason) {
        this(UUID.randomUUID(), aggregateId, Instant.now(), paymentId, reason);
    }

    @Override
    public Map<String, Object> metadata() {
        return Collections.emptyMap();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/ApiVersion.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment;
/**
 * A type-safe discriminator for identifying the requested API version of a command.
 */
public enum ApiVersion {
    V1, // Represents the direct, procedural flow
    V2, // Represents the orchestrated (state machine) flow
    V3  // Represents the hybrid saga flow
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/event/ManualInterventionRequiredEvent.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.event;

import dexter.banking.booktransfers.core.domain.payment.PaymentState;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

public record ManualInterventionRequiredEvent(
    UUID eventId,
    UUID aggregateId,
    Instant occurredOn,
    PaymentState aggregateState,
    String reason,
    Map<String, Object> metadata
) implements PaymentEvent {

    public ManualInterventionRequiredEvent(UUID aggregateId, PaymentState aggregateState, String reason, Map<String, Object> metadata) {
        this(UUID.randomUUID(), aggregateId, Instant.now(), aggregateState, reason, metadata);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/event/PaymentEvent.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.event;

import dexter.banking.booktransfers.core.domain.payment.PaymentState;
import dexter.banking.booktransfers.core.domain.shared.primitives.DomainEvent;

import java.util.UUID;

/**
 * A specialized event contract for events raised by the Payment aggregate.
 * It extends the generic DomainEvent to include the specific PaymentState.
 */
public interface PaymentEvent extends DomainEvent<UUID> {
    /** @return The state of the Payment aggregate at the time the event was raised. */
    PaymentState aggregateState();
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/event/PaymentFailedEvent.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.event;


import dexter.banking.booktransfers.core.domain.payment.PaymentState;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

public record PaymentFailedEvent(
    UUID eventId,
    UUID aggregateId,
    Instant occurredOn,
    PaymentState aggregateState,
    String reason,
    Map<String, Object> metadata
) implements PaymentEvent {

    public PaymentFailedEvent(UUID aggregateId, PaymentState aggregateState, String reason, Map<String, Object> metadata) {
        this(UUID.randomUUID(), aggregateId, Instant.now(), aggregateState, reason, metadata);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/event/PaymentInProgressEvent.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.event;


import dexter.banking.booktransfers.core.domain.payment.PaymentState;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

public record PaymentInProgressEvent(
    UUID eventId,
    UUID aggregateId,
    Instant occurredOn,
    PaymentState aggregateState,
    Map<String, Object> metadata
) implements PaymentEvent {

    public PaymentInProgressEvent(UUID aggregateId, PaymentState aggregateState, Map<String, Object> metadata) {
        this(UUID.randomUUID(), aggregateId, Instant.now(), aggregateState, metadata);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/event/PaymentRequiresComplianceCheck.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.event;

import dexter.banking.booktransfers.core.domain.payment.PaymentState;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

public record PaymentRequiresComplianceCheck(
        UUID eventId,
        UUID aggregateId,
        Instant occurredOn,
        PaymentState aggregateState,
        Map<String, Object> metadata
) implements PaymentEvent {

    public PaymentRequiresComplianceCheck(UUID aggregateId, PaymentState aggregateState, Map<String, Object> metadata) {
        this(UUID.randomUUID(), aggregateId, Instant.now(), aggregateState, metadata);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/event/PaymentSuccessfulEvent.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.event;


import dexter.banking.booktransfers.core.domain.payment.PaymentState;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

public record PaymentSuccessfulEvent(
    UUID eventId,
    UUID aggregateId,
    Instant occurredOn,
    PaymentState aggregateState,
    Map<String, Object> metadata
) implements PaymentEvent {

    public PaymentSuccessfulEvent(UUID aggregateId, PaymentState aggregateState, Map<String, Object> metadata) {
        this(UUID.randomUUID(), aggregateId, Instant.now(), aggregateState, metadata);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/exception/DomainException.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.exception;

public abstract class DomainException extends RuntimeException {
    public DomainException(String message) {
        super(message);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/exception/IdempotencyConflictException.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.exception;

public class IdempotencyConflictException extends DomainException {
    public IdempotencyConflictException(String message) {
        super(message);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/exception/PolicyViolationException.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.exception;

public class PolicyViolationException extends DomainException {
    public PolicyViolationException(String message) {
        super(message);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/exception/TransactionNotFoundException.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.exception;

/**
 * A pure domain exception thrown when a transaction cannot be found.
 * It is free of any framework annotations. The infrastructure layer will be responsible
 * for catching this and translating it into a technology-specific error,
 * like an HTTP 404 response.
 */
public class TransactionNotFoundException extends RuntimeException {
    public TransactionNotFoundException(String message) {
        super(message);
    }
}


<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/ModeOfTransfer.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment;

public enum ModeOfTransfer {
    SYNC,
    ASYNC
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/Payment.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment;


import dexter.banking.booktransfers.core.domain.payment.event.ManualInterventionRequiredEvent;
import dexter.banking.booktransfers.core.domain.payment.event.PaymentFailedEvent;
import dexter.banking.booktransfers.core.domain.payment.event.PaymentInProgressEvent;
import dexter.banking.booktransfers.core.domain.payment.event.PaymentRequiresComplianceCheck;
import dexter.banking.booktransfers.core.domain.payment.event.PaymentSuccessfulEvent;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.CreditLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessAction;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.domain.shared.policy.PolicyEvaluationContext;
import dexter.banking.booktransfers.core.domain.shared.primitives.AggregateRoot;
import lombok.Getter;

import java.util.Map;
import java.util.UUID;
@Getter
public class Payment extends AggregateRoot<UUID> {

    private final String transactionReference;
    private final String journeyName;
    private final transient BusinessPolicy policy;

    private DebitLegResult debitLegResult;
    private LimitEarmarkResult limitEarmarkResult;
    private CreditLegResult creditLegResult;
    private Status status;
    private PaymentState state;
    private Payment(UUID id, String transactionReference, String journeyName, BusinessPolicy policy, PaymentState state) {
        super(id);
        this.transactionReference = transactionReference;
        this.journeyName = journeyName;
        this.policy = policy;
        this.setState(state);
    }

    public static Payment startNew(PaymentCreationParams params, BusinessPolicy policy) {
        var payment = new Payment(params.transactionId(), params.transactionReference(), params.journeyName(), policy, PaymentState.NEW);
        PolicyEvaluationContext context = new PolicyEvaluationContext(payment.getMemento(), null);
        policy.evaluate(context, BusinessAction.START_PAYMENT);
        return payment;
    }

    public static Payment rehydrate(PaymentMemento memento, BusinessPolicy policy) {
        var payment = new Payment(memento.id(), memento.transactionReference(), memento.journeyName(), policy, memento.state());
        payment.debitLegResult = memento.debitLegResult();
        payment.limitEarmarkResult = memento.limitEarmarkResult();
        payment.creditLegResult = memento.creditLegResult();
        return payment;
    }

    public PaymentMemento getMemento() {
        return new PaymentMemento(
            this.id,
            this.transactionReference,
            this.journeyName,
            this.debitLegResult,
            this.limitEarmarkResult,
            this.creditLegResult,
            this.status,
            this.state
        );
    }

    // --- Business Methods ---

    public void flagForComplianceCheck(Map<String, Object> metadata) {
        var context = new PolicyEvaluationContext(this.getMemento(), metadata);
        this.policy.evaluate(context, BusinessAction.FLAG_FOR_COMPLIANCE);
        this.setState(PaymentState.PENDING_COMPLIANCE);
        this.registerEvent(new PaymentRequiresComplianceCheck(this.id, this.state, metadata));
    }

    public void recordLimitEarmark(LimitEarmarkResult result, Map<String, Object> metadata) {
        BusinessAction action = (result.status() == LimitEarmarkResult.LimitEarmarkStatus.SUCCESSFUL)
                ? BusinessAction.RECORD_LIMIT_EARMARK_SUCCESS
                : BusinessAction.RECORD_LIMIT_EARMARK_FAILURE;
        var context = new PolicyEvaluationContext(this.getMemento(), metadata);
        this.policy.evaluate(context, action);
        this.limitEarmarkResult = result;
        PaymentState paymentState = (action == BusinessAction.RECORD_LIMIT_EARMARK_SUCCESS)
                ? PaymentState.LIMIT_RESERVED
                : PaymentState.LIMIT_COULD_NOT_BE_RESERVED;

        this.setState(paymentState);
        this.registerEvent(new PaymentInProgressEvent(this.id, this.state, metadata));
    }

    public void recordLimitReversal(LimitEarmarkResult result, Map<String, Object> metadata) {
        BusinessAction action = (result.status() == LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_SUCCESSFUL)
                ? BusinessAction.RECORD_LIMIT_REVERSAL_SUCCESS
                : BusinessAction.RECORD_LIMIT_REVERSAL_FAILURE;
        var context = new PolicyEvaluationContext(this.getMemento(), metadata);
        this.policy.evaluate(context, action);
        this.limitEarmarkResult = result;
        PaymentState paymentState = (action == BusinessAction.RECORD_LIMIT_REVERSAL_SUCCESS)
                ? PaymentState.LIMIT_REVERSED
                : PaymentState.LIMIT_COULD_NOT_BE_REVERSED;

        this.setState(paymentState);
        this.registerEvent(new PaymentInProgressEvent(this.id, this.state, metadata));
    }

    public void recordDebit(DebitLegResult result, Map<String, Object> metadata) {
        BusinessAction action = (result.status() == DebitLegResult.DebitLegStatus.SUCCESSFUL)
                ? BusinessAction.RECORD_DEBIT_SUCCESS
                : BusinessAction.RECORD_DEBIT_FAILURE;
        var context = new PolicyEvaluationContext(this.getMemento(), metadata);
        this.policy.evaluate(context, action);

        this.debitLegResult = result;
        PaymentState paymentState = (action == BusinessAction.RECORD_DEBIT_SUCCESS)
                ? PaymentState.FUNDS_DEBITED
                : PaymentState.FUNDS_COULD_NOT_BE_DEBITED;

        this.setState(paymentState);
        this.registerEvent(new PaymentInProgressEvent(this.id, this.state, metadata));
    }

    public void recordDebitReversal(DebitLegResult result, Map<String, Object> metadata) {
        BusinessAction action = (result.status() == DebitLegResult.DebitLegStatus.REVERSAL_SUCCESSFUL)
                ? BusinessAction.RECORD_DEBIT_REVERSAL_SUCCESS
                : BusinessAction.RECORD_DEBIT_REVERSAL_FAILURE;
        var context = new PolicyEvaluationContext(this.getMemento(), metadata);
        this.policy.evaluate(context, action);

        this.debitLegResult = result;
        PaymentState paymentState = (action == BusinessAction.RECORD_DEBIT_REVERSAL_SUCCESS)
                ? PaymentState.FUNDS_DEBIT_REVERSED
                : PaymentState.FUNDS_DEBIT_COULD_NOT_BE_REVERSED;

        this.setState(paymentState);
        this.registerEvent(new PaymentInProgressEvent(this.id, this.state, metadata));
    }

    public void recordCredit(CreditLegResult result, Map<String, Object> metadata) {
        BusinessAction action = (result.status() == CreditLegResult.CreditLegStatus.SUCCESSFUL)
                ? BusinessAction.RECORD_CREDIT_SUCCESS
                : BusinessAction.RECORD_CREDIT_FAILURE;
        var context = new PolicyEvaluationContext(this.getMemento(), metadata);
        this.policy.evaluate(context, action);
        this.creditLegResult = result;
        PaymentState paymentState = (action == BusinessAction.RECORD_CREDIT_SUCCESS)
                ? PaymentState.FUNDS_CREDITED
                : PaymentState.FUNDS_COULD_NOT_BE_CREDITED;

        this.setState(paymentState);
        this.registerEvent(new PaymentInProgressEvent(this.id, this.state, metadata));
    }

    public void recordPaymentSettled(Map<String, Object> metadata) {
        var context = new PolicyEvaluationContext(this.getMemento(), metadata);
        this.policy.evaluate(context, BusinessAction.RECORD_PAYMENT_SETTLED);
        this.setState(PaymentState.SETTLED);
        this.registerEvent(new PaymentSuccessfulEvent(this.id, this.state, metadata));
    }

    public void recordPaymentFailed(String reason, Map<String, Object> metadata) {
        var context = new PolicyEvaluationContext(this.getMemento(), metadata);
        this.policy.evaluate(context, BusinessAction.RECORD_PAYMENT_FAILED);
        this.setState(PaymentState.FAILED);
        this.registerEvent(new PaymentFailedEvent(this.id, this.state, reason, metadata));
    }

    public void recordPaymentRemediationNeeded(String reason, Map<String, Object> metadata) {
        var context = new PolicyEvaluationContext(this.getMemento(), metadata);
        this.policy.evaluate(context, BusinessAction.RECORD_REMEDIATION_NEEDED);

        this.setState(PaymentState.REMEDIATION_NEEDED);
        this.registerEvent(new ManualInterventionRequiredEvent(this.id, this.state, reason, metadata));
    }

    void setState(PaymentState newState) {
        this.state = newState;
        this.updateStatusFromState();
    }

    private void updateStatusFromState() {
        switch (this.state) {
            case NEW -> this.status = Status.NEW;
            case SETTLED -> this.status = Status.SUCCESSFUL;
            case FAILED -> this.status = Status.FAILED;
            case REMEDIATION_NEEDED -> this.status = Status.REMEDIATION_REQUIRED;
            default -> this.status = Status.IN_PROGRESS;
        }
    }

    public record PaymentCreationParams(UUID transactionId, String transactionReference, String journeyName) {}

    public record PaymentMemento(
            UUID id,
            String transactionReference,
            String journeyName,
            DebitLegResult debitLegResult,
            LimitEarmarkResult limitEarmarkResult,
            CreditLegResult creditLegResult,
            Status status,
            PaymentState state
    ) {}
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/PaymentResult.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment;
import dexter.banking.booktransfers.core.domain.shared.primitives.ValueObject;

import java.util.UUID;

public record PaymentResult(
    UUID transactionId,
    String transactionReference,
    Status status,
    PaymentState state
) implements ValueObject {
    public static PaymentResult from(Payment payment) {
        return new PaymentResult(
            payment.getId(),
            payment.getTransactionReference(),
            payment.getStatus(),
            payment.getState()

        );
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/PaymentState.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment;

/**
 * Represents the business status of the Payment aggregate.
 * This is a pure domain concept, independent of any process or workflow state.
 */
public enum PaymentState {
    NEW,
    PENDING_COMPLIANCE,
    LIMIT_RESERVED,
    LIMIT_COULD_NOT_BE_RESERVED,
    FUNDS_DEBITED,
    FUNDS_COULD_NOT_BE_DEBITED,
    FUNDS_CREDITED,
    FUNDS_COULD_NOT_BE_CREDITED,

    LIMIT_REVERSED,
    LIMIT_COULD_NOT_BE_REVERSED,
    FUNDS_DEBIT_REVERSED,
    FUNDS_DEBIT_COULD_NOT_BE_REVERSED,

    // Terminal State (Requires Manual Intervention)
    SETTLED, // Terminal State (Success)
    FAILED, // Terminal State (Failure)
    REMEDIATION_NEEDED,
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/Status.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment;

/**
 * Represents the overall status of a transaction from a high-level business perspective.
 */
public enum Status {
    NEW,
    IN_PROGRESS,
    SUCCESSFUL,
    FAILED,
    REMEDIATION_REQUIRED,
}



<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/valueobject/RelId.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.valueobject;

import dexter.banking.booktransfers.core.domain.shared.primitives.ValueObject;

import java.util.UUID;

public record RelId(UUID value) implements ValueObject {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/valueobject/result/CreditLegResult.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.valueobject.result;
import dexter.banking.booktransfers.core.domain.shared.primitives.ValueObject;

import java.util.UUID;

/**
 * A pure domain value object representing the outcome of the credit leg operation.
 * It contains only the information relevant to the domain.
 */
public record CreditLegResult(
    UUID creditCardRequestId,
    CreditLegStatus status
) implements ValueObject {

    public enum CreditLegStatus {
        SUCCESSFUL,
        FAILED
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/valueobject/result/DebitLegResult.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.valueobject.result;
import dexter.banking.booktransfers.core.domain.shared.primitives.ValueObject;

import java.util.UUID;

/**
 * A pure domain value object representing the outcome of the debit leg operation or its reversal.
 * It contains only the information relevant to the domain.
 */
public record DebitLegResult(
        UUID depositId,
        DebitLegStatus status
) implements ValueObject {

    public enum DebitLegStatus {
        SUCCESSFUL,
        FAILED,
        REVERSAL_SUCCESSFUL,
        REVERSAL_FAILED
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/valueobject/result/LimitEarmarkResult.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.valueobject.result;
import dexter.banking.booktransfers.core.domain.shared.primitives.ValueObject;

import java.util.UUID;

/**
 * A pure domain value object representing the outcome of the limit earmark operation or its reversal.
 * It contains only the information relevant to the domain.
 */
public record LimitEarmarkResult(
    UUID limitId,
    LimitEarmarkStatus status
) implements ValueObject {

    public enum LimitEarmarkStatus {
        SUCCESSFUL,
        FAILED,
        REVERSAL_SUCCESSFUL,
        REVERSAL_FAILED
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/payment/valueobject/TransactionAmount.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.payment.valueobject;

import dexter.banking.booktransfers.core.domain.shared.primitives.ValueObject;

import java.math.BigDecimal;
import java.util.Currency;

public record TransactionAmount(
        BigDecimal amount,
        Currency currency
) implements ValueObject {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/shared/config/CommandProcessingContext.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.shared.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * A request-scoped carrier for data that needs to be passed between middlewares.
 * It now holds a pure domain JourneySpecification object, removing any dependency on infrastructure.
 */
@RequiredArgsConstructor
@Getter
public class CommandProcessingContext {
    private final JourneySpecification journeySpecification;
    // This context can be extended with more fields in the future.
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/shared/config/CommandProcessingContextHolder.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.shared.config;

import org.springframework.core.NamedThreadLocal;

import java.util.Optional;

/**
 * Manages the CommandProcessingContext for the current thread using a ThreadLocal.
 * This is a standard pattern for handling request-scoped data in a clean way.
 */
public final class CommandProcessingContextHolder {

    private static final ThreadLocal<CommandProcessingContext> contextHolder =
            new NamedThreadLocal<>("Command Processing Context");
    private CommandProcessingContextHolder() {}

    public static void clearContext() {
        contextHolder.remove();
    }

    public static void setContext(CommandProcessingContext context) {
        if (context == null) {
            clearContext();
        } else {
            contextHolder.set(context);
        }
    }

    public static Optional<CommandProcessingContext> getContext() {
        return Optional.ofNullable(contextHolder.get());
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/shared/config/JourneySpecification.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.shared.config;


import dexter.banking.booktransfers.core.domain.shared.primitives.ValueObject;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

/**
 * A pure, technology-agnostic value object representing the complete, unified
 * configuration for a single business journey.
 * This is the contract defined by the
 * core that the infrastructure layer must fulfill.
 */
public record JourneySpecification(
        boolean isIdempotencyEnabled,
        List<String> policies,
        Optional<BigDecimal> complianceThreshold
) implements ValueObject {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/shared/idempotency/IdempotencyData.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.shared.idempotency;

import java.util.UUID;

/**
 * A pure, technology-agnostic data record representing the state of an idempotent operation.
 * This is the contract used by the IdempotencyPort.
 *
 * @param key The unique key identifying the operation.
 * @param status The current status of the operation (STARTED or COMPLETED).
 * @param response The saved response of a COMPLETED operation.
 */
public record IdempotencyData(
    UUID key,
    IdempotencyStatus status,
    Object response
) {}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/shared/idempotency/IdempotencyStatus.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.shared.idempotency;

/**
 * A pure domain enum representing the possible states of an idempotent operation.
 */
public enum IdempotencyStatus {
    STARTED,
    COMPLETED
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/shared/policy/BusinessAction.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.shared.policy;
/**
 * A type-safe representation of a business action being attempted on an aggregate.
 * This is used by policies to select the correct set of rules to evaluate.
 */
public enum BusinessAction {
    START_PAYMENT,
    FLAG_FOR_COMPLIANCE,
    RECORD_LIMIT_EARMARK_SUCCESS,
    RECORD_LIMIT_EARMARK_FAILURE,
    RECORD_DEBIT_SUCCESS,
    RECORD_DEBIT_FAILURE,
    RECORD_CREDIT_SUCCESS,
    RECORD_CREDIT_FAILURE,
    RECORD_DEBIT_REVERSAL_SUCCESS,
    RECORD_DEBIT_REVERSAL_FAILURE,
    RECORD_LIMIT_REVERSAL_SUCCESS,
    RECORD_LIMIT_REVERSAL_FAILURE,
    RECORD_PAYMENT_SETTLED,
    RECORD_PAYMENT_FAILED,
    RECORD_REMEDIATION_NEEDED
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/shared/policy/BusinessPolicy.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.shared.policy;


import dexter.banking.booktransfers.core.domain.payment.exception.PolicyViolationException;

/**
 * The generic, universal interface for all business rule evaluation.
 * This is a domain-level port, allowing infrastructure-level policies
 * to be plugged into the domain model.
 */
@FunctionalInterface
public interface BusinessPolicy {
    /**
     * Evaluates the policy against a given context and action.
     *
     * @param context The immutable context of the aggregate's state.
     * @param action The business action being attempted.
     * @throws PolicyViolationException if any rule is violated.
     */
    void evaluate(PolicyEvaluationContext context, BusinessAction action) throws PolicyViolationException;
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/shared/policy/PolicyEvaluationContext.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.shared.policy;


import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.shared.primitives.ValueObject;

import java.util.Map;

/**
 * An immutable record used to pass all necessary information to a BusinessPolicy for evaluation.
 *
 * @param paymentMemento The snapshot of the aggregate's current state.
 * @param metadata       A flexible map for passing additional, non-domain data (e.g., from a command).
 */
public record PolicyEvaluationContext(
    Payment.PaymentMemento paymentMemento,
    Map<String, Object> metadata
) implements ValueObject {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/shared/primitives/AggregateRoot.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.shared.primitives;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public abstract class AggregateRoot<ID> extends Entity<ID> {

    private final transient List<DomainEvent<?>> domainEvents = new ArrayList<>();

    protected AggregateRoot(ID id) {
        super(id);
    }

    /**
     * Registers a domain event to be dispatched.
     * @param event The domain event to register.
     */
    public void registerEvent(DomainEvent<?> event) {
        this.domainEvents.add(event);
    }

    /**
     * Pulls all pending domain events for dispatch.
     * This is a "get-and-clear" operation, ensuring events are dispatched only once.
     * @return An unmodifiable list of the pending domain events.
     */
    public List<DomainEvent<?>> pullDomainEvents() {
        if (domainEvents.isEmpty()) {
            return Collections.emptyList();
        }
        List<DomainEvent<?>> events = List.copyOf(domainEvents);
        this.domainEvents.clear();
        return events;
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/shared/primitives/DomainEvent.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.shared.primitives;

import java.time.Instant;
import java.util.Map;
import java.util.UUID;

/**
 * A contract for a significant event that occurred within the domain.
 * Domain events are immutable facts about the past.
 * @param <ID> The type of the ID of the aggregate that raised this event.
 */
public interface DomainEvent<ID> {
    /** @return A unique identifier for this specific event instance. */
    UUID eventId();

    /** @return The identifier of the aggregate that raised this event. */
    ID aggregateId();

    /** @return The exact time the event occurred. */
    Instant occurredOn();

    /** @return A flexible payload for application-level context (e.g., webhook URLs, correlation IDs). */
    Map<String, Object> metadata();
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/shared/primitives/Entity.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.shared.primitives;

import java.util.Objects;

/**
 * A base class for domain entities.
 * An Entity is defined not by its attributes, but by a thread of continuity and identity.
 * Equality is based solely on the entity's unique identifier.
 * @param <ID> The type of the entity's identifier.
 */
public abstract class Entity<ID> {

    protected final ID id;

    protected Entity(ID id) {
        this.id = Objects.requireNonNull(id, "Entity ID cannot be null");
    }

    public ID getId() {
        return id;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Entity<?> entity = (Entity<?>) o;
        return id.equals(entity.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/domain/shared/primitives/ValueObject.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.domain.shared.primitives;

/**
 * A marker interface for Value Objects.
 * A Value Object is an object that represents a descriptive aspect of the domain
 * with no conceptual identity. They are immutable and their equality is based
 * on the structural equality of their fields. Java's `record` is the ideal
 * implementation choice for this contract.
 */
public interface ValueObject {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/compliance/ApproveComplianceCaseUseCase.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.compliance;

import dexter.banking.booktransfers.core.application.compliance.command.ApproveComplianceCaseCommand;

public interface ApproveComplianceCaseUseCase {
    void approve(ApproveComplianceCaseCommand command);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/compliance/ComplianceQueryUseCase.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.compliance;

import dexter.banking.booktransfers.core.application.compliance.query.ComplianceCaseView;

import java.util.Optional;
import java.util.UUID;

public interface ComplianceQueryUseCase {
    Optional<ComplianceCaseView> findByPaymentId(UUID paymentId);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/compliance/CreateComplianceCaseUseCase.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.compliance;

import java.util.UUID;

public interface CreateComplianceCaseUseCase {
    void create(UUID paymentId);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/compliance/RejectComplianceCaseUseCase.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.compliance;

import dexter.banking.booktransfers.core.application.compliance.command.RejectComplianceCaseCommand;

public interface RejectComplianceCaseUseCase {
    void reject(RejectComplianceCaseCommand command);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/payment/ConcludePaymentFailedUseCase.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.payment;

public interface ConcludePaymentFailedUseCase {
    void handleFailure(ConcludePaymentParams params);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/payment/ConcludePaymentParams.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.payment;

import java.util.Map;
import java.util.UUID;

/**
 * A dedicated, pure Parameter Object for the ConcludePayment use cases.
 * It decouples the use cases from any specific command DTO.
 */
public record ConcludePaymentParams(
        UUID transactionId,
        String reason,
        Map<String, Object> metadata
) {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/payment/ConcludePaymentRemediationUseCase.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.payment;

public interface ConcludePaymentRemediationUseCase {
    void handleRemediation(ConcludePaymentParams params);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/payment/ConcludePaymentSuccessUseCase.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.payment;

public interface ConcludePaymentSuccessUseCase {
    void handleSuccess(ConcludePaymentParams params);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/payment/FailPaymentParams.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.payment;

import java.util.UUID;

public record FailPaymentParams(
        UUID paymentId,
        String reason
) {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/payment/FailPaymentUseCase.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.payment;

public interface FailPaymentUseCase {
    void fail(FailPaymentParams params);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/payment/PaymentQueryUseCase.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.payment;

import dexter.banking.booktransfers.core.application.payment.query.PaymentView;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * The dedicated Driving Port for all payment query operations.
 * Its contract is defined by the lean, optimized PaymentView read model,
 * completely decoupling the query path from the write model.
 */
public interface PaymentQueryUseCase {

    Optional<PaymentView> findById(UUID transactionId);

    /**
     * Finds transactions by their business-level reference.
     * As the reference is not guaranteed to be unique, this must return a list.
     * @param transactionReference The business reference identifier.
     * @return A list of matching payment views, which may be empty.
     */
    List<PaymentView> findByReference(String transactionReference);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/payment/ResumePaymentParams.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.payment;

import java.util.UUID;

public record ResumePaymentParams(
        UUID paymentId
) {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/in/payment/ResumePaymentUseCase.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.in.payment;

public interface ResumePaymentUseCase {
    void resume(ResumePaymentParams params);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/BusinessPolicyFactory.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;


import dexter.banking.booktransfers.core.domain.shared.config.JourneySpecification;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;

/**
 * A driven port defining the contract for an adapter that can construct
 * the correct, fully-composed BusinessPolicy from a journey's specification.
 * This contract is explicit: it requires the full specification to create the policy.
 */
public interface BusinessPolicyFactory {
    /**
     * Creates a composed policy from a specific journey specification.
     *
     * @param spec The complete, unified configuration for the journey.
     * @return The composed BusinessPolicy.
     * @throws IllegalArgumentException if any policy bean name in the spec cannot be resolved.
     */
    BusinessPolicy create(JourneySpecification spec);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/ComplianceCaseRepositoryPort.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;

import dexter.banking.booktransfers.core.domain.compliance.ComplianceCase;
import java.util.Optional;
import java.util.UUID;

public interface ComplianceCaseRepositoryPort {
    void save(ComplianceCase complianceCase);
    Optional<ComplianceCase> findById(UUID complianceCaseId);
    Optional<ComplianceCase> findByPaymentId(UUID paymentId);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/ConfigurationPort.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;


import dexter.banking.booktransfers.core.domain.shared.config.JourneySpecification;

import java.util.Optional;
/**
 * A Driven Port defining the contract for a technology-agnostic configuration provider.
 * The core uses this port to request the configuration it needs, without knowing where
 * the configuration comes from (e.g., properties file, config server).
 */
public interface ConfigurationPort {
    /**
     * Finds the journey-specific configuration.
     * @param journeyIdentifier The unique identifier of the journey (e.g., "PAYMENT_SUBMIT_V1").
     * @return An Optional containing the pure, domain-aligned configuration if found.
     */
    Optional<JourneySpecification> findForJourney(String journeyIdentifier);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/CreditCardPort.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;


import dexter.banking.booktransfers.core.domain.payment.valueobject.result.CreditLegResult;

import java.util.UUID;

/**
 * Driven Port for interacting with the external Credit Card Banking service.
 * The contract is defined in terms of pure domain objects, protecting the core from
 * the specifics of the external DTOs.
 */
public interface CreditCardPort {
    CreditLegResult submitCreditCardPayment(SubmitCreditCardPaymentRequest request);
    CreditLegResult submitCreditCardReversalPayment(SubmitCreditCardReversalRequest request);

    record SubmitCreditCardPaymentRequest(UUID transactionId, String cardNumber) {}
    record SubmitCreditCardReversalRequest(UUID transactionId, UUID creditCardRequestId) {}
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/CustomerPort.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;

import dexter.banking.booktransfers.core.domain.payment.valueobject.RelId;

public interface CustomerPort {
    boolean isCustomerValid(RelId relId);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/DepositPort.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;


import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;

import java.util.UUID;

/**
 * Driven Port for interacting with the external Deposit Banking service.
 * The contract is defined in terms of pure domain objects.
 */
public interface DepositPort {
    DebitLegResult submitDeposit(SubmitDepositRequest request);
    DebitLegResult submitDepositReversal(SubmitDepositReversalRequest request);

    record SubmitDepositRequest(UUID transactionId, String accountNumber) {}
    record SubmitDepositReversalRequest(UUID transactionId, UUID reservationId) {}
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/EventDispatcherPort.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;


import dexter.banking.booktransfers.core.domain.shared.primitives.DomainEvent;

import java.util.List;

/**
 * A Driving Port for dispatching domain events to interested listeners.
 */
public interface EventDispatcherPort {
    void dispatch(List<DomainEvent<?>> events);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/IdempotencyPort.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;


import dexter.banking.booktransfers.core.domain.shared.idempotency.IdempotencyData;

import java.util.Optional;
import java.util.UUID;

/**
 * A Driven Port defining the contract for a technology-agnostic idempotency store.
 * The contract is based on explicit, single-purpose primitives.
 */
public interface IdempotencyPort {
    /**
     * Atomically attempts to acquire an exclusive lock by creating a 'STARTED' record.
     * This is the equivalent of a SET-IF-NOT-EXISTS operation.
     * @param key The idempotency key.
     * @return true if the lock was acquired (key did not exist), false otherwise.
     */
    boolean tryAcquireLock(UUID key);

    /**
     * Retrieves the current data for an idempotency key.
     * This is called only after tryAcquireLock returns false.
     * @param key The idempotency key.
     * @return An Optional containing the data for the key.
     */
    Optional<IdempotencyData> getOperationData(UUID key);

    /**
     * Marks an operation as completed, stores its result, and persists the final state.
     * This operation effectively releases the lock.
     * @param key The key of the operation.
     * @param response The successful response object to save.
     */
    void markCompleted(UUID key, Object response);

    /**
     * Releases a lock without marking the operation as complete.
     * Used for cleanup after a processing failure.
     * @param key The key of the operation to release.
     */
    void releaseLock(UUID key);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/LimitPort.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;


import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;

import java.util.UUID;

/**
 * Driven Port for interacting with the external Limit Management service.
 * The contract is defined in terms of pure domain objects.
 */
public interface LimitPort {
    LimitEarmarkResult earmarkLimit(EarmarkLimitRequest request);
    LimitEarmarkResult reverseLimitEarmark(ReverseLimitEarmarkRequest request);

    record EarmarkLimitRequest(UUID transactionId, String limitType) {}
    record ReverseLimitEarmarkRequest(UUID transactionId, UUID limitManagementId) {}
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/OrchestrationContextRepositoryPort.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;

import java.util.Optional;
import java.util.UUID;

/**
 * A dedicated, lean Driven Port for persisting the state machine's technical context.
 */
public interface OrchestrationContextRepositoryPort {
    /**
     * Persists the serialized state machine context.
     *
     * @param transactionId The unique ID of the transaction.
     * @param contextData   The raw byte array of the serialized context.
     */
    void save(UUID transactionId, byte[] contextData);

    /**
     * Retrieves the serialized state machine context.
     *
     * @param transactionId The unique ID of the transaction.
     * @return An Optional containing the raw byte array of the context if found.
     */
    Optional<byte[]> findById(UUID transactionId);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/PaymentRepositoryPort.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;

import dexter.banking.booktransfers.core.domain.payment.Payment;

import java.util.Optional;
import java.util.UUID;

/**
 * Driven Port for payment persistence. This is the contract for the database adapter.
 */
public interface PaymentRepositoryPort {
    Payment save(Payment payment);
    Payment update(Payment payment);

    /**
     * Finds the raw, persisted state (Memento) of a Payment aggregate.
     * This method intentionally returns a data-only object, not a live domain entity,
     * forcing the Application Layer to be responsible for rehydration.
     *
     * @param transactionId The unique ID of the transaction.
     * @return An Optional containing the memento if found.
     */
    Optional<Payment.PaymentMemento> findMementoById(UUID transactionId);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/TransactionLegPort.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;

/**
 * Driven Port for sending asynchronous messages to external systems (e.g., via JMS/Kafka).
 * This abstracts away the JmsTemplate dependency from the core logic.
 */
public interface TransactionLegPort {
    void sendCreditCardRequest(CreditCardPort.SubmitCreditCardPaymentRequest request);
    void sendDepositRequest(DepositPort.SubmitDepositRequest request);
    void sendLimitManagementRequest(LimitPort.EarmarkLimitRequest request);
    void sendDepositReversalRequest(DepositPort.SubmitDepositReversalRequest request);
    void sendLimitReversalRequest(LimitPort.ReverseLimitEarmarkRequest request);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./core/src/main/java/dexter/banking/booktransfers/core/port/out/WebhookPort.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.core.port.out;

import dexter.banking.booktransfers.core.domain.payment.PaymentState;

/**
 * Driven Port for sending notifications to external webhooks.
 */
public interface WebhookPort {
    void notifyTransactionStatus(String webhookUrl, WebhookNotification notification);

    /**
     * A type-safe, explicit contract for the webhook notification payload.
     * @param transactionReference The business reference for the transaction.
     * @param status The final state of the payment.
     */
    record WebhookNotification(String transactionReference, PaymentState status) {}
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/pom.xml
<<--CONTENT_START-->>
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>dexter.demo.payment</groupId>
        <artifactId>book-transfers-service</artifactId>
        <version>0.1.0-SNAPSHOT</version>
    </parent>

    <artifactId>book-transfers-infrastructure</artifactId>
    <name>Book Transfers :: Infrastructure</name>
    <description>The infrastructure module containing all adapters and policies.</description>

    <dependencies>
        <dependency>
            <groupId>dexter.demo.payment</groupId>
            <artifactId>book-transfers-core</artifactId>
            <version>0.1.0-SNAPSHOT</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-activemq</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-tx</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>jakarta.xml.bind</groupId>
            <artifactId>jakarta.xml.bind-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>dexter.demo.payment</groupId>
            <artifactId>common-domain</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
        </dependency>
    </dependencies>

</project>

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/messaging/CreditBankingListener.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.messaging;

import dexter.banking.booktransfers.core.application.payment.command.callback.ProcessCreditCardResultCommand;
import dexter.banking.commandbus.CommandBus;
import dexter.banking.model.CreditCardBankingResponse;
import dexter.banking.model.JmsConstants;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
class CreditBankingListener {

    private final CommandBus commandBus;
    private final MessagingAdapterMapper mapper;

    @JmsListener(destination = JmsConstants.CREDIT_CARD_BANKING_RESPONSE)
    public void completeCreditCardBanking(CreditCardBankingResponse result) {
        log.debug("Received Credit card banking Result DTO for txnId: {}. Sending to CommandBus.", result.getTransactionId());
        var domainResult = mapper.toDomain(result);
        var command = new ProcessCreditCardResultCommand(result.getTransactionId(), domainResult);
        commandBus.send(command);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/messaging/DepositBankingListener.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.messaging;

import dexter.banking.booktransfers.core.application.payment.command.callback.ProcessDebitResultCommand;
import dexter.banking.commandbus.CommandBus;
import dexter.banking.model.DepositBankingResponse;
import dexter.banking.model.JmsConstants;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
class DepositBankingListener {

    private final CommandBus commandBus;
    private final MessagingAdapterMapper mapper;

    @JmsListener(destination = JmsConstants.DEPOSIT_BANKING_RESPONSE)
    public void completeDepositBanking(DepositBankingResponse result) {
        log.debug("Received Deposit banking Result DTO for txnId: {}. Sending to CommandBus.", result.getTransactionId());
        var domainResult = mapper.toDomain(result);
        var command = new ProcessDebitResultCommand(result.getTransactionId(), domainResult);
        commandBus.send(command);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/messaging/DepositBankingReversalListener.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.messaging;

import dexter.banking.booktransfers.core.application.payment.command.callback.ProcessDebitReversalResultCommand;
import dexter.banking.commandbus.CommandBus;
import dexter.banking.model.DepositBankingResponse;
import dexter.banking.model.JmsConstants;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
class DepositBankingReversalListener {

    private final CommandBus commandBus;
    private final MessagingAdapterMapper mapper;

    @JmsListener(destination = JmsConstants.DEPOSIT_BANKING_REVERSAL_RESPONSE)
    public void completeDepositBankingReversal(DepositBankingResponse result) {
        log.debug("Received Deposit banking reversal DTO for txnId: {}. Sending to CommandBus.", result.getTransactionId());
        var domainResult = mapper.toReversalDomain(result);
        var command = new ProcessDebitReversalResultCommand(result.getTransactionId(), domainResult);
        commandBus.send(command);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/messaging/LimitEarmarkListener.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.messaging;

import dexter.banking.booktransfers.core.application.payment.command.callback.ProcessLimitEarmarkResultCommand;
import dexter.banking.commandbus.CommandBus;
import dexter.banking.model.JmsConstants;
import dexter.banking.model.LimitManagementResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
class LimitEarmarkListener {

    private final CommandBus commandBus;
    private final MessagingAdapterMapper mapper;

    @JmsListener(destination = JmsConstants.LIMIT_MANAGEMENT_RESPONSE)
    public void completeLimitEarmark(LimitManagementResponse result) {
        log.debug("Received Limit earmark Result DTO for txnId: {}. Sending to CommandBus.", result.getTransactionId());
        var domainResult = mapper.toDomain(result);
        var command = new ProcessLimitEarmarkResultCommand(result.getTransactionId(), domainResult);
        commandBus.send(command);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/messaging/LimitEarmarkReversalListener.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.messaging;

import dexter.banking.booktransfers.core.application.payment.command.callback.ProcessLimitReversalResultCommand;
import dexter.banking.commandbus.CommandBus;
import dexter.banking.model.JmsConstants;
import dexter.banking.model.LimitManagementResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
class LimitEarmarkReversalListener {

    private final CommandBus commandBus;
    private final MessagingAdapterMapper mapper;

    @JmsListener(destination = JmsConstants.LIMIT_MANAGEMENT_REVERSAL_RESPONSE)
    public void completeLimitEarmarkReversal(LimitManagementResponse result) {
        log.debug("Received Limit earmark reversal DTO for txnId: {}. Sending to CommandBus.", result.getTransactionId());
        var domainResult = mapper.toReversalDomain(result);
        var command = new ProcessLimitReversalResultCommand(result.getTransactionId(), domainResult);
        commandBus.send(command);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/messaging/MessagingAdapterMapper.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.messaging;

import dexter.banking.booktransfers.core.domain.payment.valueobject.result.CreditLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import dexter.banking.model.CreditCardBankingResponse;
import dexter.banking.model.CreditCardBankingStatus;
import dexter.banking.model.DepositBankingResponse;
import dexter.banking.model.DepositBankingStatus;
import dexter.banking.model.LimitEarmarkStatus;
import dexter.banking.model.LimitManagementResponse;
import org.springframework.stereotype.Component;

/**
 * A dedicated Anti-Corruption Layer (ACL) mapper for the inbound messaging adapter.
 * It translates external DTOs received from JMS queues into pure, internal domain value objects.
 */
@Component
class MessagingAdapterMapper {

    public CreditLegResult toDomain(CreditCardBankingResponse dto) {
        CreditLegResult.CreditLegStatus status = (dto.getStatus() == CreditCardBankingStatus.SUCCESSFUL)
                ? CreditLegResult.CreditLegStatus.SUCCESSFUL
                : CreditLegResult.CreditLegStatus.FAILED;
        return new CreditLegResult(dto.getCreditCardBankingId(), status);
    }

    public DebitLegResult toDomain(DepositBankingResponse dto) {
        DebitLegResult.DebitLegStatus status = (dto.getStatus() == DepositBankingStatus.SUCCESSFUL)
                ? DebitLegResult.DebitLegStatus.SUCCESSFUL
                : DebitLegResult.DebitLegStatus.FAILED;
        return new DebitLegResult(dto.getDepositId(), status);
    }

    public DebitLegResult toReversalDomain(DepositBankingResponse dto) {
        DebitLegResult.DebitLegStatus status = (dto.getStatus() == DepositBankingStatus.REVERSAL_SUCCESSFUL)
                ? DebitLegResult.DebitLegStatus.REVERSAL_SUCCESSFUL
                : DebitLegResult.DebitLegStatus.REVERSAL_FAILED;
        return new DebitLegResult(dto.getDepositId(), status);
    }

    public LimitEarmarkResult toDomain(LimitManagementResponse dto) {
        LimitEarmarkResult.LimitEarmarkStatus status = (dto.getStatus() == LimitEarmarkStatus.SUCCESSFUL)
                ? LimitEarmarkResult.LimitEarmarkStatus.SUCCESSFUL
                : LimitEarmarkResult.LimitEarmarkStatus.FAILED;
        return new LimitEarmarkResult(dto.getLimitId(), status);
    }

    public LimitEarmarkResult toReversalDomain(LimitManagementResponse dto) {
        LimitEarmarkResult.LimitEarmarkStatus status = (dto.getStatus() == LimitEarmarkStatus.REVERSAL_SUCCESSFUL)
                ? LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_SUCCESSFUL
                : LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_FAILED;
        return new LimitEarmarkResult(dto.getLimitId(), status);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/messaging/MessagingInboundAdapterConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.messaging;

import dexter.banking.booktransfers.infrastructure.FacadeConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackageClasses = MessagingInboundAdapterConfig.class)
public class MessagingInboundAdapterConfig implements FacadeConfiguration {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/web/ApiErrorResponse.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.web;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.OffsetDateTime;

/**
 * A standard DTO for returning consistent error information in API responses.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
class ApiErrorResponse {
    private OffsetDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
}



<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/web/ApiExceptionHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.web;

import dexter.banking.booktransfers.core.domain.payment.exception.IdempotencyConflictException;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import java.time.OffsetDateTime;

@ControllerAdvice
class ApiExceptionHandler {

    @ExceptionHandler(TransactionNotFoundException.class)
    public ResponseEntity<ApiErrorResponse> handleNotFoundException(TransactionNotFoundException ex, WebRequest request) {
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .timestamp(OffsetDateTime.now())
                .status(HttpStatus.NOT_FOUND.value())
                .error(HttpStatus.NOT_FOUND.getReasonPhrase())
                .message(ex.getMessage())
                .path(request.getDescription(false).replace("uri=", ""))
                .build();
        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(IdempotencyConflictException.class)
    public ResponseEntity<ApiErrorResponse> handleIdempotencyConflictException(IdempotencyConflictException ex, WebRequest request) {
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .timestamp(OffsetDateTime.now())
                .status(HttpStatus.CONFLICT.value())
                .error(HttpStatus.CONFLICT.getReasonPhrase())
                .message(ex.getMessage())
                .path(request.getDescription(false).replace("uri=", ""))
                .build();
        return new ResponseEntity<>(errorResponse, HttpStatus.CONFLICT);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/web/BookTransferController.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.web;

import dexter.banking.booktransfers.core.application.compliance.command.ApproveComplianceCaseCommand;
import dexter.banking.booktransfers.core.application.compliance.command.RejectComplianceCaseCommand;
import dexter.banking.booktransfers.core.application.compliance.query.ComplianceCaseView;
import dexter.banking.booktransfers.core.application.payment.command.HighValuePaymentCommand;
import dexter.banking.booktransfers.core.application.payment.command.PaymentCommand;
import dexter.banking.booktransfers.core.application.payment.query.PaymentView;
import dexter.banking.booktransfers.core.domain.payment.ApiVersion;
import dexter.banking.booktransfers.core.domain.payment.PaymentResult;
import dexter.banking.booktransfers.core.domain.payment.exception.TransactionNotFoundException;
import dexter.banking.booktransfers.core.port.in.compliance.ComplianceQueryUseCase;
import dexter.banking.booktransfers.core.port.in.payment.PaymentQueryUseCase;
import dexter.banking.commandbus.CommandBus;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

/**
 * The primary Driving Adapter for the REST API.
 * It now uses a dedicated query stack (PaymentQueryUseCase -> PaymentView) for reads,
 * and the command stack (CommandBus -> BookTransferResponse) for writes.
 */
@RestController
@RequestMapping("/api")
@RequiredArgsConstructor
@Validated
class BookTransferController {

    private final CommandBus commandBus;
    private final PaymentQueryUseCase paymentQueryUseCase;
    private final ComplianceQueryUseCase complianceQueryUseCase;
    private final WebMapper webMapper;

    @PostMapping("/v1/book-transfers/payment")
    public BookTransferResponse submitTransactionV1(@RequestBody @Valid BookTransferRequest bookTransferRequest) {
        PaymentCommand command = webMapper.toCommand(bookTransferRequest, ApiVersion.V1);
        PaymentResult initiatedPayment = commandBus.send(command);
        return webMapper.toResponse(initiatedPayment);
    }

    @PostMapping("/v2/book-transfers/payment")
    public BookTransferResponse submitTransactionV2(@RequestBody @Valid BookTransferRequest bookTransferRequest) {
        PaymentCommand command = webMapper.toCommand(bookTransferRequest, ApiVersion.V2);
        PaymentResult initiatedPayment = commandBus.send(command);
        return webMapper.toResponse(initiatedPayment);
    }

    @PostMapping("/v3/book-transfers/payment")
    public BookTransferResponse submitTransactionV3(@RequestBody @Valid BookTransferRequestV3 bookTransferRequest) {
        HighValuePaymentCommand command = webMapper.toCommand(bookTransferRequest);
        PaymentResult initiatedPayment = commandBus.send(command);
        return webMapper.toResponse(initiatedPayment);
    }

    @PostMapping("/v3/compliance-cases/{caseId}/approve")
    public ResponseEntity<Void> approveComplianceCase(@PathVariable UUID caseId) {
        var command = new ApproveComplianceCaseCommand(caseId);
        commandBus.send(command);
        return ResponseEntity.accepted().build();
    }

    @PostMapping("/v3/compliance-cases/{caseId}/reject")
    public ResponseEntity<Void> rejectComplianceCase(@PathVariable UUID caseId, @RequestBody @Valid RejectComplianceRequest request) {
        var command = webMapper.toCommand(caseId, request);
        commandBus.send(command);
        return ResponseEntity.accepted().build();
    }


    @GetMapping({"/v1/book-transfers/payment/{id}", "/v2/book-transfers/payment/{id}"})
    public ResponseEntity<PaymentView> getTransactionInfo(@PathVariable UUID id) {
        return paymentQueryUseCase.findById(id)
                .map(ResponseEntity::ok)
                .orElseThrow(() -> new TransactionNotFoundException("Transaction not found for id: " + id));
    }

    @GetMapping({"/v1/book-transfers/payments", "/v2/book-transfers/payments"})
    public ResponseEntity<List<PaymentView>> findTransactionsByReference(@RequestParam("reference") String reference) {
        List<PaymentView> results = paymentQueryUseCase.findByReference(reference);
        return ResponseEntity.ok(results);
    }

    @GetMapping("/v3/payments/{paymentId}/compliance-case")
    public ResponseEntity<ComplianceCaseView> getComplianceCaseByPaymentId(@PathVariable UUID paymentId) {
        return complianceQueryUseCase.findByPaymentId(paymentId)
                .map(ResponseEntity::ok)
                .orElseThrow(() -> new TransactionNotFoundException("Compliance case not found for payment id: " + paymentId));
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/web/BookTransferRequest.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.web;

import lombok.Data;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import java.util.UUID;

@Data
class BookTransferRequest {

    @NotNull(message = "idempotencyKey must not be null")
    private UUID idempotencyKey;

    @NotBlank
    String transactionReference;
    @NotBlank
    String limitType;

    @NotBlank
    String accountNumber;

    @NotBlank
    String cardNumber;

    String webhookUrl = "";

    String realtime = "";

    @Pattern(regexp = "SYNC|ASYNC", message = "Mode of transfer must be one of DIRECT, SYNC, or ASYNC")
    String modeOfTransfer = "SYNC";
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/web/BookTransferRequestV3.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.web;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

import java.math.BigDecimal;
import java.util.UUID;

@Data
class BookTransferRequestV3 {
    @NotNull(message = "idempotencyKey must not be null")
    private UUID idempotencyKey;

    @NotBlank
    String transactionReference;

    @NotNull
    private UUID relId;

    @NotNull
    @DecimalMin(value = "0.0", inclusive = false)
    private BigDecimal amount;

    @NotBlank
    private String currency;

    @NotBlank
    String limitType;

    @NotBlank
    String accountNumber;

    @NotBlank
    String cardNumber;
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/web/BookTransferResponse.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.web;

import dexter.banking.booktransfers.core.domain.payment.PaymentState;
import dexter.banking.booktransfers.core.domain.payment.Status;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

/**
 * Data Transfer Object for API responses.
 * This provides a stable, public-facing representation of a transaction's state,
 * decoupling the API clients from our internal domain model.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
class BookTransferResponse {
    private UUID transactionId;
    private Status status;
    private PaymentState state;
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/web/RejectComplianceRequest.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.web;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
class RejectComplianceRequest {
    @NotBlank(message = "A reason must be provided for rejection")
    private String reason;
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/web/WebAdapterConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.web;

import dexter.banking.booktransfers.infrastructure.FacadeConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackageClasses = WebAdapterConfig.class)
public class WebAdapterConfig implements FacadeConfiguration {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/in/web/WebMapper.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.web;
import dexter.banking.booktransfers.core.application.compliance.command.RejectComplianceCaseCommand;
import dexter.banking.booktransfers.core.application.payment.command.HighValuePaymentCommand;
import dexter.banking.booktransfers.core.application.payment.command.PaymentCommand;
import dexter.banking.booktransfers.core.domain.payment.ApiVersion;
import dexter.banking.booktransfers.core.domain.payment.ModeOfTransfer;
import dexter.banking.booktransfers.core.domain.payment.PaymentResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.RelId;
import dexter.banking.booktransfers.core.domain.payment.valueobject.TransactionAmount;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.springframework.util.StringUtils;

import java.util.Currency;
import java.util.UUID;

@Mapper(componentModel = "spring", imports = {ModeOfTransfer.class, StringUtils.class, RelId.class, TransactionAmount.class, Currency.class})
interface WebMapper {
    @Mapping(target = "modeOfTransfer", expression = "java(StringUtils.hasText(dto.getModeOfTransfer()) ? ModeOfTransfer.valueOf(dto.getModeOfTransfer().toUpperCase()) : ModeOfTransfer.ASYNC)")
    PaymentCommand toCommand(BookTransferRequest dto, ApiVersion version);

    @Mapping(target = "relId", expression = "java(new RelId(dto.getRelId()))")
    @Mapping(target = "transactionAmount", expression = "java(new TransactionAmount(dto.getAmount(), Currency.getInstance(dto.getCurrency())))")
    HighValuePaymentCommand toCommand(BookTransferRequestV3 dto);

    RejectComplianceCaseCommand toCommand(UUID complianceCaseId, RejectComplianceRequest dto);

    BookTransferResponse toResponse(PaymentResult paymentResult);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/config/ConfigAdapterConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.config;

import dexter.banking.booktransfers.infrastructure.FacadeConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackageClasses = ConfigAdapterConfig.class)
public class ConfigAdapterConfig implements FacadeConfiguration {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/config/JourneyProperties.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.config;

import lombok.Data;

import jakarta.validation.constraints.NotEmpty;
import java.math.BigDecimal;
import java.util.List;

/**
 * A single, unified DTO representing the configuration for a business journey,
 * loaded from application.yml.
 */
@Data
class JourneyProperties {
    private boolean idempotencyEnabled = false;
    @NotEmpty
    private List<String> policies;
    private BigDecimal complianceThreshold;
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/config/PropertiesConfigurationAdapter.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.config;

import dexter.banking.booktransfers.core.domain.shared.config.JourneySpecification;
import dexter.banking.booktransfers.core.port.out.ConfigurationPort;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;

/**
 * The concrete Driven Adapter that implements the ConfigurationPort.
 * This adapter knows about the specific way configuration is loaded in this application
 * (via Spring's @ConfigurationProperties) and acts as an Anti-Corruption Layer by
 * mapping the infrastructure-specific model to the pure core model.
 */
@Component
@RequiredArgsConstructor
class PropertiesConfigurationAdapter implements ConfigurationPort {

    private final ServiceConfigProperties serviceConfigProperties;
    @Override
    public Optional<JourneySpecification> findForJourney(String journeyIdentifier) {
        // 1. Get the infrastructure-specific configuration object.
        JourneyProperties infraConfig = serviceConfigProperties.getJourneys().get(journeyIdentifier);

        // 2. Map it to the pure core/domain configuration object.
        return Optional.ofNullable(infraConfig).map(this::toDomain);
    }

    private JourneySpecification toDomain(JourneyProperties infraConfig) {
        return new JourneySpecification(
                infraConfig.isIdempotencyEnabled(),
                infraConfig.getPolicies(),
                Optional.ofNullable(infraConfig.getComplianceThreshold())
        );
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/config/ServiceConfigProperties.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.validation.annotation.Validated;

import jakarta.validation.constraints.NotNull;
import java.util.Map;
@Configuration
@ConfigurationProperties(prefix = "service-config")
@Data
@Validated
class ServiceConfigProperties {
    @NotNull
    private Map<String, JourneyProperties> journeys;
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/events/compliance/TransactionalComplianceDomainEventListener.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.events.compliance;

import dexter.banking.booktransfers.core.domain.compliance.event.ComplianceCaseApproved;
import dexter.banking.booktransfers.core.domain.compliance.event.ComplianceCaseRejected;
import dexter.banking.booktransfers.core.domain.payment.PaymentState;
import dexter.banking.booktransfers.core.domain.payment.event.*;
import dexter.banking.booktransfers.core.port.in.compliance.CreateComplianceCaseUseCase;
import dexter.banking.booktransfers.core.port.in.payment.FailPaymentParams;
import dexter.banking.booktransfers.core.port.in.payment.FailPaymentUseCase;
import dexter.banking.booktransfers.core.port.in.payment.ResumePaymentParams;
import dexter.banking.booktransfers.core.port.in.payment.ResumePaymentUseCase;
import dexter.banking.booktransfers.core.port.out.WebhookPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.event.TransactionPhase;
import org.springframework.transaction.event.TransactionalEventListener;

import java.util.Map;
import java.util.UUID;

/**
 * A single, unified Spring component that listens for all domain events.
 * It uses the @TransactionalEventListener to ensure that event handling only occurs
 * AFTER the originating transaction has successfully committed. This is critical for
 * preventing inconsistent state if a webhook call fails after the DB commit.
 */
@Component
@RequiredArgsConstructor
@Slf4j
class TransactionalComplianceDomainEventListener {
    private final ResumePaymentUseCase resumePaymentUseCase;
    private final FailPaymentUseCase failPaymentUseCase;

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void on(ComplianceCaseApproved event) {
        log.info("SAGA: Received PaymentRequiresComplianceCheck for paymentId {}. Invoking CreateComplianceCaseUseCase.", event.aggregateId());

        resumePaymentUseCase.resume(new ResumePaymentParams(event.paymentId()));
    }

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void on(ComplianceCaseRejected event) {
        log.info("SAGA: Received PaymentRequiresComplianceCheck for paymentId {}. Invoking CreateComplianceCaseUseCase.", event.aggregateId());

        failPaymentUseCase.fail(new FailPaymentParams(event.paymentId(), event.reason()));
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/events/EventsAdapterConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.events;

import dexter.banking.booktransfers.infrastructure.FacadeConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackageClasses = EventsAdapterConfig.class)
public class EventsAdapterConfig implements FacadeConfiguration {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/events/payment/TransactionalPaymentEventListener.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.events.payment;

import dexter.banking.booktransfers.core.domain.compliance.event.ComplianceCaseApproved;
import dexter.banking.booktransfers.core.domain.payment.PaymentState;
import dexter.banking.booktransfers.core.domain.payment.event.*;
import dexter.banking.booktransfers.core.port.in.compliance.CreateComplianceCaseUseCase;
import dexter.banking.booktransfers.core.port.in.payment.ResumePaymentParams;
import dexter.banking.booktransfers.core.port.in.payment.ResumePaymentUseCase;
import dexter.banking.booktransfers.core.port.out.WebhookPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.event.TransactionPhase;
import org.springframework.transaction.event.TransactionalEventListener;

import java.util.Map;
import java.util.UUID;
/**
 * A single, unified Spring component that listens for all domain events.
 * It uses the @TransactionalEventListener to ensure that event handling only occurs
 * AFTER the originating transaction has successfully committed. This is critical for
 * preventing inconsistent state if a webhook call fails after the DB commit.
 */
@Component
@RequiredArgsConstructor
@Slf4j
class TransactionalPaymentEventListener {
    private final CreateComplianceCaseUseCase createComplianceCaseUseCase;
    private final WebhookPort webhookPort;

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void on(PaymentSuccessfulEvent event) {
        log.info("Handling successful payment event for transaction {}", event.aggregateId());
        notifyWebhook(event.aggregateId(), event.aggregateState(), event.metadata());
    }

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void on(PaymentFailedEvent event) {
        log.info("Handling failed payment event for transaction {}", event.aggregateId());
        notifyWebhook(event.aggregateId(), event.aggregateState(), event.metadata());
    }

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void on(ManualInterventionRequiredEvent event) {
        log.info("Handling manual intervention event for transaction {}", event.aggregateId());
        notifyWebhook(event.aggregateId(), event.aggregateState(), event.metadata());
    }

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void on(PaymentInProgressEvent event) {
        log.info("Handling in-progress payment event for transaction {}", event.aggregateId());
        var eventMetadata = event.metadata();
        boolean realtimeEnabled = eventMetadata.containsKey("realtime") && "true".equals(eventMetadata.get("realtime"));
        if (realtimeEnabled) {
            log.info("Realtime flag is set. Notifying webhook immediately for transaction {}", event.aggregateId());
            notifyWebhook(event.aggregateId(), event.aggregateState(), event.metadata());
        } else {
            log.info("Realtime flag not set or false. Skipping immediate webhook notification for transaction {}", event.aggregateId());
        }
    }

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void on(PaymentRequiresComplianceCheck event) {
        log.info("SAGA: Received PaymentRequiresComplianceCheck for paymentId {}. Invoking CreateComplianceCaseUseCase.", event.aggregateId());
        // No command object is needed for this internal-only use case.
        createComplianceCaseUseCase.create(event.aggregateId());
    }

    private void notifyWebhook(UUID aggregateId, PaymentState paymentState, Map<String, Object> metadata) {
        String webhookUrl = (String) metadata.get("webhookUrl");
        String transactionReference = (String) metadata.get("transactionReference");
        if (webhookUrl != null && !webhookUrl.isBlank()) {
            log.info("Notifying webhook {} for transaction {} with final state {}", webhookUrl, aggregateId, paymentState);
            var notification = new WebhookPort.WebhookNotification(transactionReference, paymentState);
            webhookPort.notifyTransactionStatus(webhookUrl, notification);
        } else {
            log.info("No webhook URL configured for transaction {}. Skipping notification.", aggregateId);
        }
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/events/SpringEventDispatcherAdapter.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.events;

import dexter.banking.booktransfers.core.domain.shared.primitives.DomainEvent;
import dexter.banking.booktransfers.core.port.out.EventDispatcherPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * A concrete Driven Adapter for the EventDispatcherPort that uses Spring's
 * internal ApplicationEventPublisher. This allows us to leverage Spring's
 * powerful @TransactionalEventListener for robust, transaction-aware event handling.
 */
@Component
@RequiredArgsConstructor
@Slf4j
class SpringEventDispatcherAdapter implements EventDispatcherPort {

    private final ApplicationEventPublisher eventPublisher;

    @Override
    public void dispatch(List<DomainEvent<?>> events) {
        if (events == null || events.isEmpty()) {
            return;
        }
        log.info("Publishing {} domain event(s) to the application context...", events.size());
        events.forEach(eventPublisher::publishEvent);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/http/payment/feign/CreditCardAdapter.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.http.payment.feign;

import dexter.banking.booktransfers.core.domain.payment.valueobject.result.CreditLegResult;
import dexter.banking.booktransfers.core.port.out.CreditCardPort;
import dexter.banking.model.ApiConstants;
import dexter.banking.model.CreditCardBankingRequest;
import dexter.banking.model.CreditCardBankingResponse;
import dexter.banking.model.CreditCardBankingReversalRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.context.annotation.Primary;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;

import java.util.UUID;

/**
 * Feign client adapter that implements the CreditCardPort.
 * This is the concrete implementation that knows how to talk to the external service.
 * It is composed of a raw Feign client and a mapper to act as an Anti-Corruption Layer.
 */
@Component
@Primary
class CreditCardAdapter implements CreditCardPort {

    private final RawCreditCardClient client;
    private final HttpAdapterMapper mapper;
    @Autowired
    public CreditCardAdapter(RawCreditCardClient client, HttpAdapterMapper mapper) {
        this.client = client;
        this.mapper = mapper;
    }

    @Override
    public CreditLegResult submitCreditCardPayment(SubmitCreditCardPaymentRequest command) {
        CreditCardBankingRequest request = mapper.toCreditCardBankingRequest(command);
        CreditCardBankingResponse responseDto = client.submitCreditCardPayment(request);
        return mapper.toDomain(responseDto);
    }

    @Override
    public CreditLegResult submitCreditCardReversalPayment(SubmitCreditCardReversalRequest command) {
        // This flow is not implemented in V1/V2, but is shown for architectural consistency.
        // In a real scenario, the mapper would create the reversal request from the payment state.
        throw new UnsupportedOperationException("Credit card reversal not implemented in this service");
    }

    @FeignClient(value = "credit-card-banking-service")
    interface RawCreditCardClient {
        @PostMapping(produces = MediaType.APPLICATION_JSON_VALUE, value = ApiConstants.API_CREDIT_CARD_BANKING)
        CreditCardBankingResponse submitCreditCardPayment(@RequestBody CreditCardBankingRequest creditCardBankingRequest);
        @PutMapping(
                produces = MediaType.APPLICATION_JSON_VALUE,
                value = ApiConstants.API_CREDIT_CARD_BANKING + "/{creditCardRequestId}/cancelled")
        CreditCardBankingResponse submitCreditCardReversalPayment(@PathVariable("creditCardRequestId") UUID creditCardRequestId,
                                                                  @RequestBody CreditCardBankingReversalRequest creditCardBankingReversalRequest);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/http/payment/feign/DepositAdapter.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.http.payment.feign;

import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.booktransfers.core.port.out.DepositPort;
import dexter.banking.model.ApiConstants;
import dexter.banking.model.DepositBankingRequest;
import dexter.banking.model.DepositBankingResponse;
import dexter.banking.model.DepositBankingReversalRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.context.annotation.Primary;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;

import java.util.UUID;

@Component
@Primary
class DepositAdapter implements DepositPort {

    private final RawDepositClient client;
    private final HttpAdapterMapper mapper;
    @Autowired
    public DepositAdapter(RawDepositClient client, HttpAdapterMapper mapper) {
        this.client = client;
        this.mapper = mapper;
    }

    @Override
    public DebitLegResult submitDeposit(SubmitDepositRequest command) {
        DepositBankingRequest request = mapper.toDepositBankingRequest(command);
        DepositBankingResponse responseDto = client.submitDeposit(request);
        return mapper.toDomain(responseDto);
    }

    @Override
    public DebitLegResult submitDepositReversal(SubmitDepositReversalRequest command) {
        DepositBankingReversalRequest request = mapper.toDepositReversalRequest(command);
        DepositBankingResponse responseDto = client.submitDepositReversal(command.reservationId(), request);
        return mapper.toReversalDomain(responseDto);
    }


    @FeignClient(value = "deposit-banking-service")
    interface RawDepositClient {

        @PostMapping(produces = MediaType.APPLICATION_JSON_VALUE, value = ApiConstants.API_DEPOSIT_BANKING)
        DepositBankingResponse submitDeposit(@RequestBody DepositBankingRequest reservationRequest);
        @PutMapping(
                produces = MediaType.APPLICATION_JSON_VALUE,
                value = ApiConstants.API_DEPOSIT_BANKING + "/{depositRequestId}/cancelled")
        DepositBankingResponse submitDepositReversal(@PathVariable("depositRequestId") UUID depositRequestId,
                                                     @RequestBody DepositBankingReversalRequest depositBankingReversalRequest);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/http/payment/feign/HttpAdapterMapper.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.http.payment.feign;

import dexter.banking.booktransfers.core.domain.payment.valueobject.result.CreditLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import dexter.banking.booktransfers.core.port.out.CreditCardPort;
import dexter.banking.booktransfers.core.port.out.DepositPort;
import dexter.banking.booktransfers.core.port.out.LimitPort;
import dexter.banking.model.*;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

/**
 * A dedicated Anti-Corruption Layer (ACL) mapper for the outbound HTTP adapter.
 * It translates external DTOs received from Feign clients into pure, internal domain value objects,
 * and translates the core's Parameter Objects into external request DTOs.
 */
@Mapper(componentModel = "spring", imports = {LimitEarmarkStatus.class, DepositBankingStatus.class, CreditCardBankingStatus.class})
interface HttpAdapterMapper {

    @Mapping(target = "status", expression = "java(dto.getStatus() == CreditCardBankingStatus.SUCCESSFUL ? CreditLegResult.CreditLegStatus.SUCCESSFUL : CreditLegResult.CreditLegStatus.FAILED)")
    @Mapping(target = "creditCardRequestId", source = "creditCardBankingId")
    CreditLegResult toDomain(CreditCardBankingResponse dto);

    @Mapping(target = "status", expression = "java(dto.getStatus() == DepositBankingStatus.SUCCESSFUL ? DebitLegResult.DebitLegStatus.SUCCESSFUL : DebitLegResult.DebitLegStatus.FAILED)")
    @Mapping(target = "depositId", source = "depositId")
    DebitLegResult toDomain(DepositBankingResponse dto);

    @Mapping(target = "status", expression = "java(dto.getStatus() == DepositBankingStatus.REVERSAL_SUCCESSFUL ? DebitLegResult.DebitLegStatus.REVERSAL_SUCCESSFUL : DebitLegResult.DebitLegStatus.REVERSAL_FAILED)")
    @Mapping(target = "depositId", source = "depositId")
    DebitLegResult toReversalDomain(DepositBankingResponse dto);

    @Mapping(target = "status", expression = "java(dto.getStatus() == LimitEarmarkStatus.SUCCESSFUL ? LimitEarmarkResult.LimitEarmarkStatus.SUCCESSFUL : LimitEarmarkResult.LimitEarmarkStatus.FAILED)")
    @Mapping(target = "limitId", source = "limitId")
    LimitEarmarkResult toDomain(LimitManagementResponse dto);

    @Mapping(target = "status", expression = "java(dto.getStatus() == LimitEarmarkStatus.REVERSAL_SUCCESSFUL ? LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_SUCCESSFUL : LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_FAILED)")
    @Mapping(target = "limitId", source = "limitId")
    LimitEarmarkResult toReversalDomain(LimitManagementResponse dto);

    LimitManagementRequest toLimitManagementRequest(LimitPort.EarmarkLimitRequest command);

    DepositBankingRequest toDepositBankingRequest(DepositPort.SubmitDepositRequest command);

    CreditCardBankingRequest toCreditCardBankingRequest(CreditCardPort.SubmitCreditCardPaymentRequest command);

    LimitManagementReversalRequest toLimitEarmarkReversalRequest(LimitPort.ReverseLimitEarmarkRequest command);

    DepositBankingReversalRequest toDepositReversalRequest(DepositPort.SubmitDepositReversalRequest command);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/http/payment/feign/HttpOutboundAdapterConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.http.payment.feign;

import dexter.banking.booktransfers.infrastructure.FacadeConfiguration;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableFeignClients(basePackageClasses = HttpOutboundAdapterConfig.class)
@ComponentScan(basePackageClasses = HttpOutboundAdapterConfig.class)
public class HttpOutboundAdapterConfig implements FacadeConfiguration {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/http/payment/feign/LimitAdapter.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.http.payment.feign;

import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import dexter.banking.booktransfers.core.port.out.LimitPort;
import dexter.banking.model.ApiConstants;
import dexter.banking.model.LimitManagementRequest;
import dexter.banking.model.LimitManagementResponse;
import dexter.banking.model.LimitManagementReversalRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.context.annotation.Primary;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import java.util.UUID;

@Component
@Primary
class LimitAdapter implements LimitPort {

    private final RawLimitClient client;
    private final HttpAdapterMapper mapper;
    @Autowired
    public LimitAdapter(RawLimitClient client, HttpAdapterMapper mapper) {
        this.client = client;
        this.mapper = mapper;
    }

    @Override
    public LimitEarmarkResult earmarkLimit(EarmarkLimitRequest command) {
        LimitManagementRequest request = mapper.toLimitManagementRequest(command);
        LimitManagementResponse responseDto = client.earmarkLimit(request);
        return mapper.toDomain(responseDto);
    }

    @Override
    public LimitEarmarkResult reverseLimitEarmark(ReverseLimitEarmarkRequest command) {
        LimitManagementReversalRequest request = mapper.toLimitEarmarkReversalRequest(command);
        LimitManagementResponse responseDto = client.reverseLimitEarmark(command.limitManagementId(), request);
        return mapper.toReversalDomain(responseDto);
    }

    @FeignClient(value = "limit-management-service")
    interface RawLimitClient {

        @PostMapping(produces = MediaType.APPLICATION_JSON_VALUE, value = ApiConstants.API_LIMIT_MANAGEMENT)
        LimitManagementResponse earmarkLimit(@RequestBody LimitManagementRequest limitManagementRequest);
        @PutMapping(
                produces = MediaType.APPLICATION_JSON_VALUE,
                value = ApiConstants.API_LIMIT_MANAGEMENT + "/{limitEarmarkId}/cancelled")
        LimitManagementResponse reverseLimitEarmark(@PathVariable("limitEarmarkId") UUID limitEarmarkId,
                                                    @RequestBody LimitManagementReversalRequest limitManagementReversalRequest);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/http/payment/feign/WebhookAdapter.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.http.payment.feign;

import dexter.banking.booktransfers.core.port.out.WebhookPort;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
/**
 * An adapter for the WebhookPort that uses RestTemplate.
 * This is implemented as a class because it needs to handle dynamic URLs,
 * which is simpler with RestTemplate than with Feign.
 */
@Slf4j
@Component
class WebhookAdapter implements WebhookPort {

    private final RestTemplate restTemplate = new RestTemplate();
    @Override
    public void notifyTransactionStatus(String webhookUrl, WebhookNotification notification) {
        if (webhookUrl == null || webhookUrl.trim().isEmpty()) {
            log.debug("No webhook URL provided, skipping notification.");
            return;
        }

        try {
            log.info("Sending webhook notification to {} with payload {}", webhookUrl, notification);
            restTemplate.postForObject(webhookUrl, notification, String.class);
        } catch (Exception e) {
            // In a real application, this should probably go to a retry queue.
            log.error("Error calling webhook URL: {}", webhookUrl, e);
        }
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/messaging/payment/jms/JmsAdapterMapper.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.messaging.payment.jms;

import dexter.banking.booktransfers.core.port.out.CreditCardPort;
import dexter.banking.booktransfers.core.port.out.DepositPort;
import dexter.banking.booktransfers.core.port.out.LimitPort;
import dexter.banking.model.CreditCardBankingRequest;
import dexter.banking.model.DepositBankingRequest;
import dexter.banking.model.DepositBankingReversalRequest;
import dexter.banking.model.LimitManagementRequest;
import dexter.banking.model.LimitManagementReversalRequest;
import org.mapstruct.Mapper;

/**
 * A dedicated Anti-Corruption Layer (ACL) mapper for the outbound JMS adapter.
 * It translates the core's lean Parameter Objects into external request DTOs for messaging.
 */
@Mapper(componentModel = "spring")
interface JmsAdapterMapper {
    LimitManagementRequest toLimitManagementRequest(LimitPort.EarmarkLimitRequest request);

    DepositBankingRequest toDepositBankingRequest(DepositPort.SubmitDepositRequest request);

    CreditCardBankingRequest toCreditCardBankingRequest(CreditCardPort.SubmitCreditCardPaymentRequest request);

    LimitManagementReversalRequest toLimitEarmarkReversalRequest(LimitPort.ReverseLimitEarmarkRequest request);

    DepositBankingReversalRequest toDepositReversalRequest(DepositPort.SubmitDepositReversalRequest request);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/messaging/payment/jms/JmsTransactionLegAdapter.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.messaging.payment.jms;

import dexter.banking.booktransfers.core.port.out.CreditCardPort;
import dexter.banking.booktransfers.core.port.out.DepositPort;
import dexter.banking.booktransfers.core.port.out.LimitPort;
import dexter.banking.booktransfers.core.port.out.TransactionLegPort;
import dexter.banking.model.JmsConstants;
import lombok.RequiredArgsConstructor;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;
/**
 * A Driven Adapter that implements the MessagingPort for sending outbound JMS messages.
 * This class encapsulates all the logic and dependencies related to JMS,
 * hiding the JmsTemplate from the application core.
 */
@Component
@RequiredArgsConstructor
class JmsTransactionLegAdapter implements TransactionLegPort {

    private final JmsTemplate jmsTemplate;
    private final JmsAdapterMapper mapper;
    @Override
    public void sendCreditCardRequest(CreditCardPort.SubmitCreditCardPaymentRequest request) {
        var dto = mapper.toCreditCardBankingRequest(request);
        jmsTemplate.convertAndSend(JmsConstants.CREDIT_CARD_BANKING_REQUEST, dto);
    }

    @Override
    public void sendDepositRequest(DepositPort.SubmitDepositRequest request) {
        var dto = mapper.toDepositBankingRequest(request);
        jmsTemplate.convertAndSend(JmsConstants.DEPOSIT_BANKING_REQUEST, dto);
    }

    @Override
    public void sendLimitManagementRequest(LimitPort.EarmarkLimitRequest request) {
        var dto = mapper.toLimitManagementRequest(request);
        jmsTemplate.convertAndSend(JmsConstants.LIMIT_MANAGEMENT_REQUEST, dto);
    }

    @Override
    public void sendDepositReversalRequest(DepositPort.SubmitDepositReversalRequest request) {
        var dto = mapper.toDepositReversalRequest(request);
        jmsTemplate.convertAndSend(JmsConstants.DEPOSIT_BANKING_REVERSAL_REQUEST, dto);
    }

    @Override
    public void sendLimitReversalRequest(LimitPort.ReverseLimitEarmarkRequest request) {
        var dto = mapper.toLimitEarmarkReversalRequest(request);
        jmsTemplate.convertAndSend(JmsConstants.LIMIT_MANAGEMENT_REVERSAL_REQUEST, dto);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/messaging/payment/jms/MessagingOutboundAdapterConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.messaging.payment.jms;

import dexter.banking.booktransfers.infrastructure.FacadeConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackageClasses = MessagingOutboundAdapterConfig.class)
public class MessagingOutboundAdapterConfig implements FacadeConfiguration {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/compliance/mongo/ComplianceCaseDocument.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.compliance.mongo;

import dexter.banking.booktransfers.core.domain.compliance.ComplianceStatus;
import lombok.Data;
import org.bson.types.ObjectId;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;

import java.util.UUID;

@Data
@Document(collection = "compliance_cases")
class ComplianceCaseDocument {
    @Id
    private ObjectId _id;

    @Indexed(unique = true)
    private UUID caseId;

    private UUID paymentId;
    private ComplianceStatus status;
    private String reason;
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/compliance/mongo/CompliancePersistenceConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.compliance.mongo;

import dexter.banking.booktransfers.infrastructure.FacadeConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;

@Configuration
@EnableMongoRepositories(basePackageClasses = CompliancePersistenceConfig.class)
@ComponentScan(basePackageClasses = CompliancePersistenceConfig.class)
public class CompliancePersistenceConfig implements FacadeConfiguration {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/compliance/mongo/CompliancePersistenceMapper.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.compliance.mongo;

import dexter.banking.booktransfers.core.domain.compliance.ComplianceCase;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
interface CompliancePersistenceMapper {

    @Mapping(target = "caseId", source = "id")
    @Mapping(target = "_id", ignore = true)
    ComplianceCaseDocument toDocument(ComplianceCase aggregate);

    default ComplianceCase toDomain(ComplianceCaseDocument document) {
        if (document == null) {
            return null;
        }
        // This default implementation is required to correctly use the aggregate's static factory method.
        return ComplianceCase.rehydrate(
                document.getCaseId(),
                document.getPaymentId(),
                document.getStatus(),
                document.getReason()
        );
    }

    @Mapping(target = "caseId", ignore = true)
    @Mapping(target = "paymentId", ignore = true)
    @Mapping(target = "_id", ignore = true)
    void updateDocument(@MappingTarget ComplianceCaseDocument doc, ComplianceCase aggregate);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/compliance/mongo/MongoComplianceCaseRepository.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.compliance.mongo;

import dexter.banking.booktransfers.core.domain.compliance.ComplianceCase;
import dexter.banking.booktransfers.core.port.out.ComplianceCaseRepositoryPort;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;
import java.util.UUID;

@Component
@RequiredArgsConstructor
class MongoComplianceCaseRepository implements ComplianceCaseRepositoryPort {

    private final SpringMongoComplianceCaseRepository repository;
    private final CompliancePersistenceMapper mapper;

    @Override
    public void save(ComplianceCase complianceCase) {
        repository.findByCaseId(complianceCase.getId())
                .ifPresentOrElse(
                        doc -> {
                            mapper.updateDocument(doc, complianceCase);
                            repository.save(doc);
                        },
                        () -> {
                            ComplianceCaseDocument doc = mapper.toDocument(complianceCase);
                            repository.save(doc);
                        }
                );
    }

    @Override
    public Optional<ComplianceCase> findById(UUID complianceCaseId) {
        return repository.findByCaseId(complianceCaseId)
                .map(mapper::toDomain);
    }

    @Override
    public Optional<ComplianceCase> findByPaymentId(UUID paymentId) {
        return repository.findByPaymentId(paymentId)
                .map(mapper::toDomain);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/compliance/mongo/MongoComplianceQueryHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.compliance.mongo;

import dexter.banking.booktransfers.core.application.compliance.query.ComplianceCaseView;
import dexter.banking.booktransfers.core.port.in.compliance.ComplianceQueryUseCase;
import dexter.banking.booktransfers.core.port.out.ComplianceCaseRepositoryPort;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;
import java.util.UUID;

@Component
@RequiredArgsConstructor
class MongoComplianceQueryHandler implements ComplianceQueryUseCase {

    private final ComplianceCaseRepositoryPort complianceCaseRepository;

    @Override
    public Optional<ComplianceCaseView> findByPaymentId(UUID paymentId) {
        return complianceCaseRepository.findByPaymentId(paymentId)
                .map(complianceCase -> new ComplianceCaseView(
                        complianceCase.getId(),
                        complianceCase.getPaymentId(),
                        complianceCase.getStatus()
                ));
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/compliance/mongo/SpringMongoComplianceCaseRepository.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.compliance.mongo;

import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

@Repository
interface SpringMongoComplianceCaseRepository extends MongoRepository<ComplianceCaseDocument, String> {
    Optional<ComplianceCaseDocument> findByCaseId(UUID caseId);
    Optional<ComplianceCaseDocument> findByPaymentId(UUID paymentId);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/idempotency/mongo/IdempotencyPersistenceConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.idempotency.mongo;

import dexter.banking.booktransfers.infrastructure.FacadeConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;

@Configuration
@EnableMongoRepositories(basePackageClasses = IdempotencyPersistenceConfig.class)
@ComponentScan(basePackageClasses = IdempotencyPersistenceConfig.class)
public class IdempotencyPersistenceConfig implements FacadeConfiguration {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/idempotency/mongo/MongoIdempotencyAdapter.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.idempotency.mongo;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import dexter.banking.booktransfers.core.domain.shared.idempotency.IdempotencyData;
import dexter.banking.booktransfers.core.domain.shared.idempotency.IdempotencyStatus;
import dexter.banking.booktransfers.core.port.out.IdempotencyPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;
import org.springframework.stereotype.Component;
import java.time.Instant;
import java.util.Optional;
import java.util.UUID;

@Component
@RequiredArgsConstructor
@Slf4j
class MongoIdempotencyAdapter implements IdempotencyPort {

    private final MongoTemplate mongoTemplate;
    private final ObjectMapper objectMapper;

    @Override
    public boolean tryAcquireLock(UUID key) {
        MongoIdempotencyRecord newRecord = new MongoIdempotencyRecord();
        newRecord.setIdempotencyKey(key.toString());
        newRecord.setStatus(MongoIdempotencyStatus.STARTED);
        newRecord.setCreatedAt(Instant.now());

        try {
            // This atomic operation is the core of the lock acquisition.
            mongoTemplate.insert(newRecord);
            return true; // Success, we created the record.
        } catch (DuplicateKeyException e) {
            // The key already exists, so we did not acquire the lock.
            log.debug("Idempotency key {} already exists, lock not acquired.", key);
            return false;
        }
    }

    @Override
    public Optional<IdempotencyData> getOperationData(UUID key) {
        Query query = new Query(Criteria.where("_id").is(key.toString()));
        MongoIdempotencyRecord record = mongoTemplate.findOne(query, MongoIdempotencyRecord.class);
        return Optional.ofNullable(record).map(this::toDomain);
    }

    @Override
    public void markCompleted(UUID key, Object response) {
        try {
            String responseBody = (response == null || response.getClass().equals(Void.class) || response.getClass().equals(Void.TYPE)) ?
                    null : objectMapper.writeValueAsString(response);
            String responseClassName = (response == null) ? Void.class.getName() : response.getClass().getName();

            Query query = new Query(Criteria.where("_id").is(key.toString()));
            Update update = new Update()
                    .set("status", MongoIdempotencyStatus.COMPLETED)
                    .set("responseBody", responseBody)
                    .set("responseClassName", responseClassName);
            mongoTemplate.updateFirst(query, update, MongoIdempotencyRecord.class);
        } catch (JsonProcessingException e) {
            log.error("FATAL: Failed to serialize response for idempotency key {}. Lock will be released.", key, e);
            releaseLock(key); // Ensure we don't leave a dangling lock
            throw new RuntimeException("Failed to serialize idempotent response", e);
        }
    }

    @Override
    public void releaseLock(UUID key) {
        log.warn("Releasing idempotency lock for key: {}", key);
        Query query = new Query(Criteria.where("_id").is(key.toString()));
        mongoTemplate.remove(query, MongoIdempotencyRecord.class);
    }

    // --- Anti-Corruption Mapping ---
    private IdempotencyData toDomain(MongoIdempotencyRecord document) {
        if (document == null) {
            return null;
        }
        Object response = document.getResponse(objectMapper)
                .orElse(null); // The raw response object

        IdempotencyStatus domainStatus =
                IdempotencyStatus.valueOf(document.getStatus().name());

        return new IdempotencyData(
                UUID.fromString(document.getIdempotencyKey()),
                domainStatus,
                response
        );
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/idempotency/mongo/MongoIdempotencyRecord.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.idempotency.mongo;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.SneakyThrows;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;

import java.time.Instant;
import java.util.Optional;

@Document(collection = "idempotency_records")
@Data
@NoArgsConstructor
class MongoIdempotencyRecord {
    @Id
    private String idempotencyKey;
    private MongoIdempotencyStatus status;
    private String responseClassName;
    private String responseBody;

    @Indexed(expireAfterSeconds = 86400) // 24 hours
    private Instant createdAt;
    @SneakyThrows
    public Optional<Object> getResponse(ObjectMapper objectMapper) {
        if (this.status != MongoIdempotencyStatus.COMPLETED) {
            return Optional.empty();
        }
        if (this.responseBody == null || this.responseClassName.equals(Void.class.getName())) {
            return Optional.of(Void.TYPE);
        }
        Class<?> responseClass = Class.forName(this.responseClassName);
        return Optional.of(objectMapper.readValue(this.responseBody, responseClass));
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/idempotency/mongo/MongoIdempotencyStatus.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.idempotency.mongo;

enum MongoIdempotencyStatus {
    STARTED,
    COMPLETED
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/payment/mongo/MongoOrchestrationContextRepository.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.payment.mongo;

import dexter.banking.booktransfers.core.port.out.OrchestrationContextRepositoryPort;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;
import java.util.UUID;

/**
 * A dedicated, technical persistence adapter for the state machine context.
 * It implements the OrchestrationContextRepositoryPort and has only one job:
 * to save and retrieve the raw byte array of the serialized context.
 */
@Component
@RequiredArgsConstructor
class MongoOrchestrationContextRepository implements OrchestrationContextRepositoryPort {

    private final SpringMongoTransactionRepository repository;

    @Override
    public void save(UUID transactionId, byte[] contextData) {
        TransactionDocument doc = repository.findByTransactionId(transactionId)
                .orElseThrow(() -> new IllegalStateException("Cannot save context for a non-existent transaction: " + transactionId));
        doc.setOrchestrationContext(contextData);
        repository.save(doc);
    }

    @Override
    public Optional<byte[]> findById(UUID transactionId) {
        return repository.findByTransactionId(transactionId)
                .map(TransactionDocument::getOrchestrationContext);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/payment/mongo/MongoPaymentQueryHandler.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.payment.mongo;

import dexter.banking.booktransfers.core.application.payment.query.PaymentView;
import dexter.banking.booktransfers.core.port.in.payment.PaymentQueryUseCase;
import lombok.RequiredArgsConstructor;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * The Query Adapter for payments.
 * This is a highly-optimized implementation that uses MongoDB projections to fetch
 * only the necessary data, mapping it directly to the lean PaymentView read model.
 * It completely bypasses the rich domain model for reads.
 */
@Component
@RequiredArgsConstructor
class MongoPaymentQueryHandler implements PaymentQueryUseCase {

    private final MongoTemplate mongoTemplate;
    private static final String TRANSACTION_COLLECTION = "transaction_info";

    @Override
    public Optional<PaymentView> findById(UUID transactionId) {
        Query query = new Query(Criteria.where("transactionId").is(transactionId));
        addProjection(query);

        PaymentView result = mongoTemplate.findOne(query, PaymentView.class, TRANSACTION_COLLECTION);
        return Optional.ofNullable(result);
    }

    @Override
    public List<PaymentView> findByReference(String transactionReference) {
        Query query = new Query(Criteria.where("transactionReference").is(transactionReference));
        addProjection(query);
        return mongoTemplate.find(query, PaymentView.class, TRANSACTION_COLLECTION);
    }

    private void addProjection(Query query) {
        // CRITICAL: Use projection to fetch ONLY the fields we need.
        // This is the key to a performant query stack.
        query.fields()
                .include("transactionId")
                .include("transactionReference")
                .include("status")
                .include("state");
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/payment/mongo/MongoPaymentRepository.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.payment.mongo;

import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.port.out.PaymentRepositoryPort;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;
import java.util.UUID;

@Component("mongodb")
@RequiredArgsConstructor
class MongoPaymentRepository implements PaymentRepositoryPort {

    private final SpringMongoTransactionRepository repository;
    private final PersistenceMapper mapper;

    @Override
    public Payment save(Payment payment) {
        TransactionDocument document = mapper.toDocument(payment);
        repository.save(document);
        // We return the original aggregate as its state is authoritative.
        // The saved document is just a persistence artifact.
        return payment;
    }

    @Override
    public Payment update(Payment payment) {
        TransactionDocument doc = repository.findByTransactionId(payment.getId())
                .orElseThrow(() -> new IllegalStateException("Attempted to update a non-existent payment: " + payment.getId()));
        mapper.updateDocumentFromDomain(doc, payment);
        repository.save(doc);
        // Return original aggregate, which holds the live BusinessPolicy and correct state.
        return payment;
    }

    @Override
    public Optional<Payment.PaymentMemento> findMementoById(UUID transactionId) {
        return repository.findByTransactionId(transactionId)
                .map(mapper::toMemento);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/payment/mongo/PaymentPersistenceConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.payment.mongo;

import dexter.banking.booktransfers.infrastructure.FacadeConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;

@Configuration
@EnableMongoRepositories(basePackageClasses = PaymentPersistenceConfig.class)
@ComponentScan(basePackageClasses = PaymentPersistenceConfig.class)
public class PaymentPersistenceConfig implements FacadeConfiguration {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/payment/mongo/PersistenceMapper.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.payment.mongo;

import dexter.banking.booktransfers.core.domain.payment.Payment;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
interface PersistenceMapper {

    @Mapping(target = "id", source = "transactionId")
    Payment.PaymentMemento toMemento(TransactionDocument document);

    @Mapping(target = "transactionId", source = "memento.id")
    @Mapping(target = "transactionReference", source = "memento.transactionReference")
    @Mapping(target = "journeyName", source = "memento.journeyName")
    @Mapping(target = "status", source = "memento.status")
    @Mapping(target = "state", source = "memento.state")
    @Mapping(target = "debitLegResult", source = "memento.debitLegResult")
    @Mapping(target = "limitEarmarkResult", source = "memento.limitEarmarkResult")
    @Mapping(target = "creditLegResult", source = "memento.creditLegResult")
    @Mapping(target = "_id", ignore = true)
    @Mapping(target = "orchestrationContext", ignore = true)
    TransactionDocument toDocument(Payment payment);

    @Mapping(target = "transactionId", source = "memento.id")
    @Mapping(target = "transactionReference", source = "memento.transactionReference")
    @Mapping(target = "journeyName", source = "memento.journeyName")
    @Mapping(target = "status", source = "memento.status")
    @Mapping(target = "state", source = "memento.state")
    @Mapping(target = "debitLegResult", source = "memento.debitLegResult")
    @Mapping(target = "limitEarmarkResult", source = "memento.limitEarmarkResult")
    @Mapping(target = "creditLegResult", source = "memento.creditLegResult")
    @Mapping(target = "_id", ignore = true)
    @Mapping(target = "orchestrationContext", ignore = true)
    void updateDocumentFromDomain(@MappingTarget TransactionDocument doc, Payment payment);
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/payment/mongo/SpringMongoTransactionRepository.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.payment.mongo;

import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * The internal Spring Data MongoDB repository interface.
 * This is an implementation detail of the persistence adapter and is not exposed
 * to the application core. It works with the TransactionDocument.
 */
@Repository
interface SpringMongoTransactionRepository extends MongoRepository<TransactionDocument, String> {
    Optional<TransactionDocument> findByTransactionId(UUID transactionId);
}



<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/payment/mongo/TransactionDocument.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.payment.mongo;

import dexter.banking.booktransfers.core.domain.payment.PaymentState;
import dexter.banking.booktransfers.core.domain.payment.Status;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.CreditLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import lombok.Getter;
import lombok.Setter;
import org.bson.types.ObjectId;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;

import java.util.UUID;

@Setter
@Getter
@Document(collection = "transaction_info")
class TransactionDocument {

    @Id
    private ObjectId _id;
    @Indexed(unique = true)
    private UUID transactionId;
    private String transactionReference;
    private String journeyName; // Persisted context for rehydration

    // The document now stores the pure, lean domain value objects.
    private DebitLegResult debitLegResult;
    private LimitEarmarkResult limitEarmarkResult;
    private CreditLegResult creditLegResult;
    private Status status = Status.NEW;
    private PaymentState state = PaymentState.NEW;

    // This infrastructure-specific field is persisted here, not in the domain model.
    private byte[] orchestrationContext;
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/stub/customer/CustomerAdapterConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.stub.customer;

import dexter.banking.booktransfers.infrastructure.FacadeConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackageClasses = CustomerAdapterConfig.class)
public class CustomerAdapterConfig implements FacadeConfiguration {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/adapter/out/stub/customer/CustomerAdapterStub.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.stub.customer;

import dexter.banking.booktransfers.core.domain.payment.valueobject.RelId;
import dexter.banking.booktransfers.core.port.out.CustomerPort;
import org.springframework.stereotype.Component;

@Component
class CustomerAdapterStub implements CustomerPort {
    @Override
    public boolean isCustomerValid(RelId relId) {
        if (relId == null || relId.value() == null) {
            return false;
        }
        // As per the requirement, this stub provides a nuanced check.
        // It fails validation if the UUID string ends with 'X' (case-insensitive),
        // allowing us to test the failure path.
        return !relId.value().toString().toUpperCase().endsWith("X");
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/FacadeConfiguration.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure;

/**
 * A marker interface for all public infrastructure adapter @Configuration classes.
 *
 * This interface is used by a custom ComponentScan filter in the main application
 * to discover and activate infrastructure "plugins" in a controlled and explicit way.
 * An adapter is only active if its public facade implements this interface.
 */
public interface FacadeConfiguration {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/policy/CompositeBusinessPolicy.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.policy;

import dexter.banking.booktransfers.core.domain.payment.exception.PolicyViolationException;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessAction;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.domain.shared.policy.PolicyEvaluationContext;
import lombok.RequiredArgsConstructor;

import java.util.List;

/**
 * A concrete implementation of the Composite Pattern for BusinessPolicy.
 * It allows multiple policies to be chained together and evaluated as a single unit.
 * Evaluation stops at the first policy that throws a PolicyViolationException.
 */
@RequiredArgsConstructor
class CompositeBusinessPolicy implements BusinessPolicy {

    private final List<BusinessPolicy> policies;

    @Override
    public void evaluate(PolicyEvaluationContext context, BusinessAction action) throws PolicyViolationException {
        for (BusinessPolicy policy : policies) {
            policy.evaluate(context, action);
        }
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/policy/PolicyConfig.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.policy;

import dexter.banking.booktransfers.infrastructure.FacadeConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackageClasses = PolicyConfig.class)
public class PolicyConfig implements FacadeConfiguration {
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/policy/SpringBeanBusinessPolicyFactory.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.policy;

import dexter.banking.booktransfers.core.domain.shared.config.JourneySpecification;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.port.out.BusinessPolicyFactory;
import lombok.RequiredArgsConstructor;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

/**
 * The concrete Driven Adapter for the BusinessPolicyFactory.
 * This adapter uses the Spring ApplicationContext to look up named policy beans,
 * centralizing the logic for policy composition.
 */
@Component
@RequiredArgsConstructor
class SpringBeanBusinessPolicyFactory implements BusinessPolicyFactory {

    private final ApplicationContext applicationContext;

    @Override
    public BusinessPolicy create(JourneySpecification spec) {
        if (spec.policies() == null || spec.policies().isEmpty()) {
            throw new IllegalArgumentException("Journey specification must contain at least one policy.");
        }

        List<BusinessPolicy> policies = spec.policies().stream()
                .map(beanName -> applicationContext.getBean(beanName, BusinessPolicy.class))
                .collect(Collectors.toList());

        return new CompositeBusinessPolicy(policies);
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/src/main/java/dexter/banking/booktransfers/infrastructure/policy/StateTransitionPolicy.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.policy;

import dexter.banking.booktransfers.core.domain.payment.PaymentState;
import dexter.banking.booktransfers.core.domain.payment.exception.PolicyViolationException;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessAction;
import dexter.banking.booktransfers.core.domain.shared.policy.BusinessPolicy;
import dexter.banking.booktransfers.core.domain.shared.policy.PolicyEvaluationContext;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.Collections;

/**
 * A concrete BusinessPolicy that enforces the state transition graph for a Payment.
 * It uses a declarative, fluent DSL to construct the state machine rules,
 * making them human-readable, composable, and easier to maintain.
 */
@Component("stateTransitionPolicy")
class StateTransitionPolicy implements BusinessPolicy {

    private static final Map<BusinessAction, Set<PaymentState>> ALLOWED_TRANSITIONS = new TransitionRuleBuilder()
        .allow(BusinessAction.START_PAYMENT).from(PaymentState.NEW)

        // V3 Hybrid Saga: Flag for compliance after a successful limit reservation.
        .allow(BusinessAction.FLAG_FOR_COMPLIANCE).from(PaymentState.LIMIT_RESERVED)

        // Limit Earmark
        .allow(BusinessAction.RECORD_LIMIT_EARMARK_SUCCESS).from(PaymentState.NEW)
        .allow(BusinessAction.RECORD_LIMIT_EARMARK_FAILURE).from(PaymentState.NEW)

        // Debit: Can occur after limit is reserved (V1/V2) OR after compliance check (V3).
        .allow(BusinessAction.RECORD_DEBIT_SUCCESS).from(PaymentState.LIMIT_RESERVED, PaymentState.PENDING_COMPLIANCE)
        .allow(BusinessAction.RECORD_DEBIT_FAILURE).from(PaymentState.LIMIT_RESERVED, PaymentState.PENDING_COMPLIANCE)

        // Credit
        .allow(BusinessAction.RECORD_CREDIT_SUCCESS).from(PaymentState.FUNDS_DEBITED)
        .allow(BusinessAction.RECORD_CREDIT_FAILURE).from(PaymentState.FUNDS_DEBITED)

        // Debit Reversal (from Credit Failure)
        .allow(BusinessAction.RECORD_DEBIT_REVERSAL_SUCCESS).from(PaymentState.FUNDS_COULD_NOT_BE_CREDITED)
        .allow(BusinessAction.RECORD_DEBIT_REVERSAL_FAILURE).from(PaymentState.FUNDS_COULD_NOT_BE_CREDITED)

        // Limit Reversal (from Debit Failure or Debit Reversal)
        .allow(BusinessAction.RECORD_LIMIT_REVERSAL_SUCCESS).from(PaymentState.FUNDS_COULD_NOT_BE_DEBITED, PaymentState.FUNDS_DEBIT_REVERSED, PaymentState.PENDING_COMPLIANCE)
        .allow(BusinessAction.RECORD_LIMIT_REVERSAL_FAILURE).from(PaymentState.FUNDS_COULD_NOT_BE_DEBITED, PaymentState.FUNDS_DEBIT_REVERSED, PaymentState.PENDING_COMPLIANCE)

        // Finalization
        .allow(BusinessAction.RECORD_PAYMENT_SETTLED).from(PaymentState.FUNDS_CREDITED)
        .allow(BusinessAction.RECORD_PAYMENT_FAILED).from(PaymentState.LIMIT_REVERSED, PaymentState.LIMIT_COULD_NOT_BE_RESERVED)

        // Remediation can be triggered from any state in case of a catastrophic, unrecoverable error.
        .allow(BusinessAction.RECORD_REMEDIATION_NEEDED).from(EnumSet.allOf(PaymentState.class))

        .build();


    @Override
    public void evaluate(PolicyEvaluationContext context, BusinessAction action) throws PolicyViolationException {
        final PaymentState currentState = context.paymentMemento().state();
        final Set<PaymentState> allowedStates = ALLOWED_TRANSITIONS.get(action);

        if (allowedStates == null || !allowedStates.contains(currentState)) {
            throw new PolicyViolationException(
                    "Action " + action + " is not allowed in the current state " + currentState +
                            ". Allowed states are: " + (allowedStates != null ? allowedStates : "NONE")
            );
        }
    }

    /**
     * A private fluent builder to create a readable DSL for defining transition rules.
     */
    private static class TransitionRuleBuilder {
        private final Map<BusinessAction, Set<PaymentState>> rules = new HashMap<>();
        private BusinessAction currentAction;

        public ActionConfigurer allow(BusinessAction action) {
            this.currentAction = action;
            return new ActionConfigurer(this);
        }

        private void addRule(Set<PaymentState> states) {
            rules.put(currentAction, Collections.unmodifiableSet(states));
        }

        public Map<BusinessAction, Set<PaymentState>> build() {
            return Collections.unmodifiableMap(rules);
        }

        // Inner class to enforce the .from() part of the DSL
        private static class ActionConfigurer {
            private final TransitionRuleBuilder parentBuilder;

            ActionConfigurer(TransitionRuleBuilder parentBuilder) {
                this.parentBuilder = parentBuilder;
            }

            public TransitionRuleBuilder from(PaymentState... allowedStates) {
                parentBuilder.addRule(EnumSet.copyOf(Arrays.asList(allowedStates)));
                return parentBuilder;
            }

            public TransitionRuleBuilder from(Set<PaymentState> allowedStates) {
                parentBuilder.addRule(allowedStates);
                return parentBuilder;
            }
        }
    }
}
<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/target/generated-sources/annotations/dexter/banking/booktransfers/infrastructure/adapter/in/web/WebMapperImpl.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.in.web;

import dexter.banking.booktransfers.core.application.compliance.command.RejectComplianceCaseCommand;
import dexter.banking.booktransfers.core.application.payment.command.HighValuePaymentCommand;
import dexter.banking.booktransfers.core.application.payment.command.PaymentCommand;
import dexter.banking.booktransfers.core.domain.payment.ApiVersion;
import dexter.banking.booktransfers.core.domain.payment.ModeOfTransfer;
import dexter.banking.booktransfers.core.domain.payment.PaymentResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.RelId;
import dexter.banking.booktransfers.core.domain.payment.valueobject.TransactionAmount;
import java.util.Currency;
import java.util.UUID;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-04T20:37:30+0530",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 21.0.7 (Eclipse Adoptium)"
)
@Component
class WebMapperImpl implements WebMapper {

    @Override
    public PaymentCommand toCommand(BookTransferRequest dto, ApiVersion version) {
        if ( dto == null && version == null ) {
            return null;
        }

        PaymentCommand.PaymentCommandBuilder paymentCommand = PaymentCommand.builder();

        if ( dto != null ) {
            paymentCommand.idempotencyKey( dto.getIdempotencyKey() );
            paymentCommand.transactionReference( dto.getTransactionReference() );
            paymentCommand.limitType( dto.getLimitType() );
            paymentCommand.accountNumber( dto.getAccountNumber() );
            paymentCommand.cardNumber( dto.getCardNumber() );
            paymentCommand.webhookUrl( dto.getWebhookUrl() );
            paymentCommand.realtime( dto.getRealtime() );
        }
        paymentCommand.version( version );
        paymentCommand.modeOfTransfer( StringUtils.hasText(dto.getModeOfTransfer()) ? ModeOfTransfer.valueOf(dto.getModeOfTransfer().toUpperCase()) : ModeOfTransfer.ASYNC );

        return paymentCommand.build();
    }

    @Override
    public HighValuePaymentCommand toCommand(BookTransferRequestV3 dto) {
        if ( dto == null ) {
            return null;
        }

        HighValuePaymentCommand.HighValuePaymentCommandBuilder highValuePaymentCommand = HighValuePaymentCommand.builder();

        highValuePaymentCommand.idempotencyKey( dto.getIdempotencyKey() );
        highValuePaymentCommand.transactionReference( dto.getTransactionReference() );
        highValuePaymentCommand.limitType( dto.getLimitType() );
        highValuePaymentCommand.accountNumber( dto.getAccountNumber() );
        highValuePaymentCommand.cardNumber( dto.getCardNumber() );

        highValuePaymentCommand.relId( new RelId(dto.getRelId()) );
        highValuePaymentCommand.transactionAmount( new TransactionAmount(dto.getAmount(), Currency.getInstance(dto.getCurrency())) );

        return highValuePaymentCommand.build();
    }

    @Override
    public RejectComplianceCaseCommand toCommand(UUID complianceCaseId, RejectComplianceRequest dto) {
        if ( complianceCaseId == null && dto == null ) {
            return null;
        }

        String reason = null;
        if ( dto != null ) {
            reason = dto.getReason();
        }
        UUID complianceCaseId1 = null;
        complianceCaseId1 = complianceCaseId;

        RejectComplianceCaseCommand rejectComplianceCaseCommand = new RejectComplianceCaseCommand( complianceCaseId1, reason );

        return rejectComplianceCaseCommand;
    }

    @Override
    public BookTransferResponse toResponse(PaymentResult paymentResult) {
        if ( paymentResult == null ) {
            return null;
        }

        BookTransferResponse.BookTransferResponseBuilder bookTransferResponse = BookTransferResponse.builder();

        bookTransferResponse.transactionId( paymentResult.transactionId() );
        bookTransferResponse.status( paymentResult.status() );
        bookTransferResponse.state( paymentResult.state() );

        return bookTransferResponse.build();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/target/generated-sources/annotations/dexter/banking/booktransfers/infrastructure/adapter/out/http/payment/feign/HttpAdapterMapperImpl.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.http.payment.feign;

import dexter.banking.booktransfers.core.domain.payment.valueobject.result.CreditLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import dexter.banking.booktransfers.core.port.out.CreditCardPort;
import dexter.banking.booktransfers.core.port.out.DepositPort;
import dexter.banking.booktransfers.core.port.out.LimitPort;
import dexter.banking.model.CreditCardBankingRequest;
import dexter.banking.model.CreditCardBankingResponse;
import dexter.banking.model.CreditCardBankingStatus;
import dexter.banking.model.DepositBankingRequest;
import dexter.banking.model.DepositBankingResponse;
import dexter.banking.model.DepositBankingReversalRequest;
import dexter.banking.model.DepositBankingStatus;
import dexter.banking.model.LimitEarmarkStatus;
import dexter.banking.model.LimitManagementRequest;
import dexter.banking.model.LimitManagementResponse;
import dexter.banking.model.LimitManagementReversalRequest;
import java.util.UUID;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-04T20:37:41+0530",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 21.0.7 (Eclipse Adoptium)"
)
@Component
class HttpAdapterMapperImpl implements HttpAdapterMapper {

    @Override
    public CreditLegResult toDomain(CreditCardBankingResponse dto) {
        if ( dto == null ) {
            return null;
        }

        UUID creditCardRequestId = null;

        creditCardRequestId = dto.getCreditCardBankingId();

        CreditLegResult.CreditLegStatus status = dto.getStatus() == CreditCardBankingStatus.SUCCESSFUL ? CreditLegResult.CreditLegStatus.SUCCESSFUL : CreditLegResult.CreditLegStatus.FAILED;

        CreditLegResult creditLegResult = new CreditLegResult( creditCardRequestId, status );

        return creditLegResult;
    }

    @Override
    public DebitLegResult toDomain(DepositBankingResponse dto) {
        if ( dto == null ) {
            return null;
        }

        UUID depositId = null;

        depositId = dto.getDepositId();

        DebitLegResult.DebitLegStatus status = dto.getStatus() == DepositBankingStatus.SUCCESSFUL ? DebitLegResult.DebitLegStatus.SUCCESSFUL : DebitLegResult.DebitLegStatus.FAILED;

        DebitLegResult debitLegResult = new DebitLegResult( depositId, status );

        return debitLegResult;
    }

    @Override
    public DebitLegResult toReversalDomain(DepositBankingResponse dto) {
        if ( dto == null ) {
            return null;
        }

        UUID depositId = null;

        depositId = dto.getDepositId();

        DebitLegResult.DebitLegStatus status = dto.getStatus() == DepositBankingStatus.REVERSAL_SUCCESSFUL ? DebitLegResult.DebitLegStatus.REVERSAL_SUCCESSFUL : DebitLegResult.DebitLegStatus.REVERSAL_FAILED;

        DebitLegResult debitLegResult = new DebitLegResult( depositId, status );

        return debitLegResult;
    }

    @Override
    public LimitEarmarkResult toDomain(LimitManagementResponse dto) {
        if ( dto == null ) {
            return null;
        }

        UUID limitId = null;

        limitId = dto.getLimitId();

        LimitEarmarkResult.LimitEarmarkStatus status = dto.getStatus() == LimitEarmarkStatus.SUCCESSFUL ? LimitEarmarkResult.LimitEarmarkStatus.SUCCESSFUL : LimitEarmarkResult.LimitEarmarkStatus.FAILED;

        LimitEarmarkResult limitEarmarkResult = new LimitEarmarkResult( limitId, status );

        return limitEarmarkResult;
    }

    @Override
    public LimitEarmarkResult toReversalDomain(LimitManagementResponse dto) {
        if ( dto == null ) {
            return null;
        }

        UUID limitId = null;

        limitId = dto.getLimitId();

        LimitEarmarkResult.LimitEarmarkStatus status = dto.getStatus() == LimitEarmarkStatus.REVERSAL_SUCCESSFUL ? LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_SUCCESSFUL : LimitEarmarkResult.LimitEarmarkStatus.REVERSAL_FAILED;

        LimitEarmarkResult limitEarmarkResult = new LimitEarmarkResult( limitId, status );

        return limitEarmarkResult;
    }

    @Override
    public LimitManagementRequest toLimitManagementRequest(LimitPort.EarmarkLimitRequest command) {
        if ( command == null ) {
            return null;
        }

        LimitManagementRequest.LimitManagementRequestBuilder limitManagementRequest = LimitManagementRequest.builder();

        limitManagementRequest.transactionId( command.transactionId() );
        limitManagementRequest.limitType( command.limitType() );

        return limitManagementRequest.build();
    }

    @Override
    public DepositBankingRequest toDepositBankingRequest(DepositPort.SubmitDepositRequest command) {
        if ( command == null ) {
            return null;
        }

        DepositBankingRequest.DepositBankingRequestBuilder depositBankingRequest = DepositBankingRequest.builder();

        depositBankingRequest.transactionId( command.transactionId() );
        depositBankingRequest.accountNumber( command.accountNumber() );

        return depositBankingRequest.build();
    }

    @Override
    public CreditCardBankingRequest toCreditCardBankingRequest(CreditCardPort.SubmitCreditCardPaymentRequest command) {
        if ( command == null ) {
            return null;
        }

        CreditCardBankingRequest.CreditCardBankingRequestBuilder creditCardBankingRequest = CreditCardBankingRequest.builder();

        creditCardBankingRequest.transactionId( command.transactionId() );
        creditCardBankingRequest.cardNumber( command.cardNumber() );

        return creditCardBankingRequest.build();
    }

    @Override
    public LimitManagementReversalRequest toLimitEarmarkReversalRequest(LimitPort.ReverseLimitEarmarkRequest command) {
        if ( command == null ) {
            return null;
        }

        LimitManagementReversalRequest.LimitManagementReversalRequestBuilder limitManagementReversalRequest = LimitManagementReversalRequest.builder();

        limitManagementReversalRequest.transactionId( command.transactionId() );
        limitManagementReversalRequest.limitManagementId( command.limitManagementId() );

        return limitManagementReversalRequest.build();
    }

    @Override
    public DepositBankingReversalRequest toDepositReversalRequest(DepositPort.SubmitDepositReversalRequest command) {
        if ( command == null ) {
            return null;
        }

        DepositBankingReversalRequest.DepositBankingReversalRequestBuilder depositBankingReversalRequest = DepositBankingReversalRequest.builder();

        depositBankingReversalRequest.transactionId( command.transactionId() );
        depositBankingReversalRequest.reservationId( command.reservationId() );

        return depositBankingReversalRequest.build();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/target/generated-sources/annotations/dexter/banking/booktransfers/infrastructure/adapter/out/messaging/payment/jms/JmsAdapterMapperImpl.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.messaging.payment.jms;

import dexter.banking.booktransfers.core.port.out.CreditCardPort;
import dexter.banking.booktransfers.core.port.out.DepositPort;
import dexter.banking.booktransfers.core.port.out.LimitPort;
import dexter.banking.model.CreditCardBankingRequest;
import dexter.banking.model.DepositBankingRequest;
import dexter.banking.model.DepositBankingReversalRequest;
import dexter.banking.model.LimitManagementRequest;
import dexter.banking.model.LimitManagementReversalRequest;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-04T20:37:41+0530",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 21.0.7 (Eclipse Adoptium)"
)
@Component
class JmsAdapterMapperImpl implements JmsAdapterMapper {

    @Override
    public LimitManagementRequest toLimitManagementRequest(LimitPort.EarmarkLimitRequest request) {
        if ( request == null ) {
            return null;
        }

        LimitManagementRequest.LimitManagementRequestBuilder limitManagementRequest = LimitManagementRequest.builder();

        limitManagementRequest.transactionId( request.transactionId() );
        limitManagementRequest.limitType( request.limitType() );

        return limitManagementRequest.build();
    }

    @Override
    public DepositBankingRequest toDepositBankingRequest(DepositPort.SubmitDepositRequest request) {
        if ( request == null ) {
            return null;
        }

        DepositBankingRequest.DepositBankingRequestBuilder depositBankingRequest = DepositBankingRequest.builder();

        depositBankingRequest.transactionId( request.transactionId() );
        depositBankingRequest.accountNumber( request.accountNumber() );

        return depositBankingRequest.build();
    }

    @Override
    public CreditCardBankingRequest toCreditCardBankingRequest(CreditCardPort.SubmitCreditCardPaymentRequest request) {
        if ( request == null ) {
            return null;
        }

        CreditCardBankingRequest.CreditCardBankingRequestBuilder creditCardBankingRequest = CreditCardBankingRequest.builder();

        creditCardBankingRequest.transactionId( request.transactionId() );
        creditCardBankingRequest.cardNumber( request.cardNumber() );

        return creditCardBankingRequest.build();
    }

    @Override
    public LimitManagementReversalRequest toLimitEarmarkReversalRequest(LimitPort.ReverseLimitEarmarkRequest request) {
        if ( request == null ) {
            return null;
        }

        LimitManagementReversalRequest.LimitManagementReversalRequestBuilder limitManagementReversalRequest = LimitManagementReversalRequest.builder();

        limitManagementReversalRequest.transactionId( request.transactionId() );
        limitManagementReversalRequest.limitManagementId( request.limitManagementId() );

        return limitManagementReversalRequest.build();
    }

    @Override
    public DepositBankingReversalRequest toDepositReversalRequest(DepositPort.SubmitDepositReversalRequest request) {
        if ( request == null ) {
            return null;
        }

        DepositBankingReversalRequest.DepositBankingReversalRequestBuilder depositBankingReversalRequest = DepositBankingReversalRequest.builder();

        depositBankingReversalRequest.transactionId( request.transactionId() );
        depositBankingReversalRequest.reservationId( request.reservationId() );

        return depositBankingReversalRequest.build();
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/target/generated-sources/annotations/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/compliance/mongo/CompliancePersistenceMapperImpl.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.compliance.mongo;

import dexter.banking.booktransfers.core.domain.compliance.ComplianceCase;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-04T20:37:30+0530",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 21.0.7 (Eclipse Adoptium)"
)
@Component
class CompliancePersistenceMapperImpl implements CompliancePersistenceMapper {

    @Override
    public ComplianceCaseDocument toDocument(ComplianceCase aggregate) {
        if ( aggregate == null ) {
            return null;
        }

        ComplianceCaseDocument complianceCaseDocument = new ComplianceCaseDocument();

        complianceCaseDocument.setCaseId( aggregate.getId() );
        complianceCaseDocument.setPaymentId( aggregate.getPaymentId() );
        complianceCaseDocument.setStatus( aggregate.getStatus() );
        complianceCaseDocument.setReason( aggregate.getReason() );

        return complianceCaseDocument;
    }

    @Override
    public void updateDocument(ComplianceCaseDocument doc, ComplianceCase aggregate) {
        if ( aggregate == null ) {
            return;
        }

        doc.setStatus( aggregate.getStatus() );
        doc.setReason( aggregate.getReason() );
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./infrastructure/target/generated-sources/annotations/dexter/banking/booktransfers/infrastructure/adapter/out/persistence/payment/mongo/PersistenceMapperImpl.java
<<--CONTENT_START-->>
package dexter.banking.booktransfers.infrastructure.adapter.out.persistence.payment.mongo;

import dexter.banking.booktransfers.core.domain.payment.Payment;
import dexter.banking.booktransfers.core.domain.payment.PaymentState;
import dexter.banking.booktransfers.core.domain.payment.Status;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.CreditLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.DebitLegResult;
import dexter.banking.booktransfers.core.domain.payment.valueobject.result.LimitEarmarkResult;
import java.util.UUID;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-04T20:37:30+0530",
    comments = "version: 1.5.5.Final, compiler: javac, environment: Java 21.0.7 (Eclipse Adoptium)"
)
@Component
class PersistenceMapperImpl implements PersistenceMapper {

    @Override
    public Payment.PaymentMemento toMemento(TransactionDocument document) {
        if ( document == null ) {
            return null;
        }

        UUID id = null;
        String transactionReference = null;
        String journeyName = null;
        DebitLegResult debitLegResult = null;
        LimitEarmarkResult limitEarmarkResult = null;
        CreditLegResult creditLegResult = null;
        Status status = null;
        PaymentState state = null;

        id = document.getTransactionId();
        transactionReference = document.getTransactionReference();
        journeyName = document.getJourneyName();
        debitLegResult = document.getDebitLegResult();
        limitEarmarkResult = document.getLimitEarmarkResult();
        creditLegResult = document.getCreditLegResult();
        status = document.getStatus();
        state = document.getState();

        Payment.PaymentMemento paymentMemento = new Payment.PaymentMemento( id, transactionReference, journeyName, debitLegResult, limitEarmarkResult, creditLegResult, status, state );

        return paymentMemento;
    }

    @Override
    public TransactionDocument toDocument(Payment payment) {
        if ( payment == null ) {
            return null;
        }

        TransactionDocument transactionDocument = new TransactionDocument();

        transactionDocument.setTransactionId( paymentMementoId( payment ) );
        transactionDocument.setTransactionReference( paymentMementoTransactionReference( payment ) );
        transactionDocument.setJourneyName( paymentMementoJourneyName( payment ) );
        transactionDocument.setStatus( paymentMementoStatus( payment ) );
        transactionDocument.setState( paymentMementoState( payment ) );
        transactionDocument.setDebitLegResult( paymentMementoDebitLegResult( payment ) );
        transactionDocument.setLimitEarmarkResult( paymentMementoLimitEarmarkResult( payment ) );
        transactionDocument.setCreditLegResult( paymentMementoCreditLegResult( payment ) );

        return transactionDocument;
    }

    @Override
    public void updateDocumentFromDomain(TransactionDocument doc, Payment payment) {
        if ( payment == null ) {
            return;
        }

        doc.setTransactionId( paymentMementoId( payment ) );
        doc.setTransactionReference( paymentMementoTransactionReference( payment ) );
        doc.setJourneyName( paymentMementoJourneyName( payment ) );
        doc.setStatus( paymentMementoStatus( payment ) );
        doc.setState( paymentMementoState( payment ) );
        doc.setDebitLegResult( paymentMementoDebitLegResult( payment ) );
        doc.setLimitEarmarkResult( paymentMementoLimitEarmarkResult( payment ) );
        doc.setCreditLegResult( paymentMementoCreditLegResult( payment ) );
    }

    private UUID paymentMementoId(Payment payment) {
        if ( payment == null ) {
            return null;
        }
        Payment.PaymentMemento memento = payment.getMemento();
        if ( memento == null ) {
            return null;
        }
        UUID id = memento.id();
        if ( id == null ) {
            return null;
        }
        return id;
    }

    private String paymentMementoTransactionReference(Payment payment) {
        if ( payment == null ) {
            return null;
        }
        Payment.PaymentMemento memento = payment.getMemento();
        if ( memento == null ) {
            return null;
        }
        String transactionReference = memento.transactionReference();
        if ( transactionReference == null ) {
            return null;
        }
        return transactionReference;
    }

    private String paymentMementoJourneyName(Payment payment) {
        if ( payment == null ) {
            return null;
        }
        Payment.PaymentMemento memento = payment.getMemento();
        if ( memento == null ) {
            return null;
        }
        String journeyName = memento.journeyName();
        if ( journeyName == null ) {
            return null;
        }
        return journeyName;
    }

    private Status paymentMementoStatus(Payment payment) {
        if ( payment == null ) {
            return null;
        }
        Payment.PaymentMemento memento = payment.getMemento();
        if ( memento == null ) {
            return null;
        }
        Status status = memento.status();
        if ( status == null ) {
            return null;
        }
        return status;
    }

    private PaymentState paymentMementoState(Payment payment) {
        if ( payment == null ) {
            return null;
        }
        Payment.PaymentMemento memento = payment.getMemento();
        if ( memento == null ) {
            return null;
        }
        PaymentState state = memento.state();
        if ( state == null ) {
            return null;
        }
        return state;
    }

    private DebitLegResult paymentMementoDebitLegResult(Payment payment) {
        if ( payment == null ) {
            return null;
        }
        Payment.PaymentMemento memento = payment.getMemento();
        if ( memento == null ) {
            return null;
        }
        DebitLegResult debitLegResult = memento.debitLegResult();
        if ( debitLegResult == null ) {
            return null;
        }
        return debitLegResult;
    }

    private LimitEarmarkResult paymentMementoLimitEarmarkResult(Payment payment) {
        if ( payment == null ) {
            return null;
        }
        Payment.PaymentMemento memento = payment.getMemento();
        if ( memento == null ) {
            return null;
        }
        LimitEarmarkResult limitEarmarkResult = memento.limitEarmarkResult();
        if ( limitEarmarkResult == null ) {
            return null;
        }
        return limitEarmarkResult;
    }

    private CreditLegResult paymentMementoCreditLegResult(Payment payment) {
        if ( payment == null ) {
            return null;
        }
        Payment.PaymentMemento memento = payment.getMemento();
        if ( memento == null ) {
            return null;
        }
        CreditLegResult creditLegResult = memento.creditLegResult();
        if ( creditLegResult == null ) {
            return null;
        }
        return creditLegResult;
    }
}

<<--FILE_END-->>
<<--FILE_START-->>
Path: ./pom.xml
<<--CONTENT_START-->>
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>dexter.demo.payment</groupId>
        <artifactId>payment-service</artifactId>
        <version>0.1.0-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>book-transfers-service</artifactId>
    <version>0.1.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <name>Book Transfers Service (Parent)</name>
    <description>Own Account Fund Transfers Service</description>

    <modules>
        <module>core</module>
        <module>infrastructure</module>
        <module>app</module>
    </modules>

    <properties>
        <java.version>21</java.version>
        <spring-shell.version>3.3.1</spring-shell.version>
        <mapstruct.version>1.5.5.Final</mapstruct.version>
        <lombok-mapstruct-binding.version>0.2.0</lombok-mapstruct-binding.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>dexter.demo.payment</groupId>
                <artifactId>book-transfers-core</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>dexter.demo.payment</groupId>
                <artifactId>book-transfers-infrastructure</artifactId>
                <version>${project.version}</version>
            </dependency>
            <dependency>
                <groupId>dexter.demo.payment</groupId>
                <artifactId>common-domain</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>org.springframework.shell</groupId>
                <artifactId>spring-shell-starter</artifactId>
                <version>${spring-shell.version}</version>
            </dependency>

            <dependency>
                <groupId>org.mapstruct</groupId>
                <artifactId>mapstruct</artifactId>
                <version>${mapstruct.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>${maven-compiler-plugin.version}</version>
                    <configuration>
                        <source>${java.version}</source>
                        <target>${java.version}</target>
                        <annotationProcessorPaths>
                            <path>
                                <groupId>org.mapstruct</groupId>
                                <artifactId>mapstruct-processor</artifactId>
                                <version>${mapstruct.version}</version>
                            </path>
                            <path>
                                <groupId>org.projectlombok</groupId>
                                <artifactId>lombok</artifactId>
                                <version>${lombok.version}</version>
                            </path>
                            <path>
                                <groupId>org.projectlombok</groupId>
                                <artifactId>lombok-mapstruct-binding</artifactId>
                                <version>${lombok-mapstruct-binding.version}</version>
                            </path>
                        </annotationProcessorPaths>
                    </configuration>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>

</project>

<<--FILE_END-->>
