The Grand Design: Moving Orchestration to the Core

The objective is to refactor the V2 orchestration logic into first-class command handlers within the application core. This will eliminate unnecessary indirection and make the orchestrators the true owners of the payment processing use case.

Here is the complete plan, with all the nuts and bolts:

1. Core Application Layer (core/usecase)

    Delete:

        SubmitPaymentV2CommandHandler.java: This broker is no longer needed.

        The entire core/usecase/payment/event package (Record...Command and Record...CommandHandler classes): This logic will be absorbed by the new orchestrator handlers.

        core/port/TransactionOrchestratorPort.java: The orchestrators will be handlers, not port implementations.

        core/port/AsyncOrchestrationEventPort.java: Obsoleted by direct method calls to the async handler.

    Create:

        core/usecase/payment/orchestration/AsyncPaymentV2CommandHandler.java: This new class will:

            Implement CommandHandler<PaymentCommand, PaymentResult>.

            Use its matches() method to claim commands for V2 and ASYNC mode.

            Contain the async state machine logic.

            Be injected with PaymentRepositoryPort, PaymentPolicyFactory, etc.

            Expose public methods like processLimitEarmarkResult(..) for JMS listeners to call. These methods will contain the full rehydration and process continuation logic.

        core/usecase/payment/orchestration/SyncPaymentV2CommandHandler.java: This new class will:

            Implement CommandHandler<PaymentCommand, PaymentResult>.

            Use its matches() method to claim commands for V2 and SYNC mode.

            Contain the sync state machine logic.

    Move & Relocate:

        The entire infrastructure/adapter/out/orchestration package will be moved into core/usecase/payment/orchestration.

        Its contents will be renamed and refactored to remove the "adapter" nomenclature (e.g., TransactionOrchestratorAdapter becomes part of AsyncPaymentV2CommandHandler).

2. Infrastructure Layer (infrastructure)

    Refactor JMS Listeners (infrastructure/adapter/in/messaging):

        All five listeners (CreditBankingListener, etc.) will be simplified.

        They will no longer create and dispatch Record...Commands.

        Instead, they will be injected with the AsyncPaymentV2CommandHandler and will make direct method calls (e.g., orchestrator.processCreditLegResult(...)).

The MVP (Minimum Viable Product) Approach

As you suggested, we will not implement this in a single "big bang." We will break it down into two distinct, verifiable MVPs. We will iterate on MVP 1 until it is perfect before beginning MVP 2.

MVP 1: Refactor the Synchronous Flow

    Goal: To move the entire synchronous orchestration into the core and make it a fully functional, self-contained command handler.

    Why first?: It is the simpler of the two flows as it does not involve JMS listeners or the complexities of asynchronous state rehydration, making it an ideal first step.

    Key Steps for MVP 1:

        Create the new core/usecase/payment/orchestration structure.

        Move the relevant sync components (SyncStateMachine..., sync actions) into this new structure.

        Create the new SyncPaymentV2CommandHandler, integrating the moved logic.

        Delete the old SubmitPaymentV2CommandHandler.

        Ensure the command bus correctly routes SYNC mode commands to this new handler.

MVP 2: Refactor the Asynchronous Flow

    Goal: To move the asynchronous orchestration into the core, eliminate the Record...Command subsystem, and refactor the JMS listeners.

    Why second?: This builds upon the structural changes of MVP 1 and tackles the more complex logic of async events and state management.


com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `dexter.banking.booktransfers.core.usecase.payment.PaymentCommand` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)
 at [Source: (byte[])"{"paymentId":"73d468d8-9dac-4f2a-81d0-239c5335fefb","request":{"idempotencyKey":"73d468d8-9dac-4f2a-81d0-239c5335fefb","transactionReference":"REF-V2-ASYNC-1756622046","limitType":"Daily","accountNumber":"1312134","cardNumber":"123111","webhookUrl":"","realtime":"","modeOfTransfer":"ASYNC","version":"V2","identifier":"PAYMENT_SUBMIT_V2_ASYNC"},"currentState":"EARMARKING_LIMIT","id":"73d468d8-9dac-4f2a-81d0-239c5335fefb"}"; line: 1, column: 64] (through reference chain: dexter.banking.booktransfers.core.usecase.payment.orchestration.async.component.AsyncTransactionContext["request"])


Objective for next iteration:


Right now our TransactionContexts contain the PaymentCommand, which is not deserializable.


I don't want our TransactionContexts to contain directly injected commands or repsonse or anything, TransactionContext should have seriazilable data fields for all the fields (required or not) from the current injected required fields. And a mapper to create TransactionContexts and get the original objects back from it.


For instance I want my AysncTransactionContext to have all the bare fields from PaymentCommand flattened inside the AsyncTransactionContext instead of having a reference object of the same, a mapper can do this task, and we will have our independent implementation of context, not relying on the serialiazability of the PaymentCommand and other items. Similarly for TransactionContext


@Getter

public class AsyncTransactionContext implements StateMachineContext<ProcessState> {


    private final UUID paymentId;

    private final PaymentCommand request;

    private ProcessState currentState;