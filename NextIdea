Objective of the next iteration.
I want to present this project as a opinionated implementation of DDD, Hexagonal, Orchestrated architecture solution.
For me to demonstrably say that, I have to capture enough complexity to be able to stand to reason. I can't just present a toy project and toy use case which hasn't involved in DDD, hasn't encountered practical complexities with Hexagonal architecture, or hasn't encountered the limitations of my hash-map based statemachine.
For this very reason I have a grand plan. Stated concisely below.
Project book-transfers-service: The V3 Hybrid Saga Design Blueprint
This document codifies the final, agreed-upon architectural design for the "V3 Hybrid Saga with Compliance Check" feature for the book-transfers-service project. It serves as the definitive blueprint for the next implementation iteration.
1. The Three-Tiered API Vision
The service's evolution is defined by a three-tiered API vision, where each version showcases a progressively more sophisticated architectural pattern:
    API V1: The baseline. A purely procedural, non-orchestrated flow.
    API V2: The introduction to orchestration. A fully orchestrated flow using the State Machine Saga pattern, demonstrating both pure-async (fire-and-forget with JMS callbacks) and pure-sync (fully blocking) implementations.
    API V3 (The Hybrid Saga): The pinnacle. An advanced, orchestrated flow demonstrating a hybrid of synchronous and asynchronous steps, integrated with a multi-aggregate DDD workflow.
        The design makes a deliberate trade-off: a slightly longer initial API response time in exchange for the immense business value of immediate validation of a critical business rule (the transaction limit). This is an accepted and mature architectural decision.

2. The V3 Implementation Blueprint
The design to realize the V3 vision introduces the following new components and patterns.
A. The V3 Command & API Entry Point
    API Endpoint: A new POST /api/v3/book-transfers/payment endpoint.
    Richer Command: The endpoint maps its request body to a new PaymentCommandV3, which contains the RelId and TransactionAmount Value Objects.
    Dedicated Handler: A new SubmitPaymentV3CommandHandler is responsible for initial business validation (e.g., validating the customer via a CustomerPort) before delegating to the V3 orchestrator.
B. The V3 Hybrid Orchestrator & State Machine
    New Orchestrator Adapter: A HybridStateMachineOrchestratorAdapter provides the concrete implementation for the V3 flow.
    New State Machine Configuration: A dedicated V3StateMachineConfig defines the hybrid logic:
        Synchronous First Step: The FSM's initial action is synchronous, making a direct, blocking Feign call to the limit service. Upon success, it immediately returns the next event to fire, causing the FSM to cascade without pausing.
        Compliance Pause: A subsequent action checks if compliance is required. If so, the PaymentTransaction AR transitions to a PENDING_COMPLIANCE state, publishes a PaymentRequiresComplianceCheck event, and the FSM pauses execution.
        Asynchronous Later Steps: Once resumed, subsequent states (debit/credit legs) are handled by asynchronous actions (e.g., sending JMS messages) where the FSM pauses to await callbacks.
C. The Compliance Subdomain & Eventing
    ComplianceCase Aggregate Root: A new AR to manage the lifecycle (PENDING, APPROVED, REJECTED) of a compliance check.
    ComplianceSaga: A stateless application service that listens for domain events (PaymentRequiresComplianceCheck, ComplianceCaseApproved, etc.) and issues corresponding commands to orchestrate the process between the PaymentTransaction and ComplianceCase aggregates.
    DomainEventPublisher: A new driven port and adapter responsible for dispatching domain events after an aggregate has been successfully persisted. The initial implementation uses Spring's built-in ApplicationEventPublisher.
3. The V3 Lifecycle Narrative
The interaction of these components follows this precise sequence:
    A high-value payment request hits POST /v3/payment.
    The SubmitPaymentV3CommandHandler validates the customer exists via CustomerPort.
    The HybridStateMachineOrchestratorAdapter is invoked.
    The V3 State Machine begins. The first action makes a synchronous, blocking Feign call to the Limit service. If it fails, the entire V3 request fails and an immediate error is returned.
    The limit is approved. The FSM cascades to an action that determines a compliance check is needed.
    The PaymentTransaction AR's state is set to PENDING_COMPLIANCE, and it publishes a PaymentRequiresComplianceCheck event. The FSM pauses. The initial HTTP response (e.g., 202 Accepted) is sent to the client.
    The DomainEventPublisher dispatches the event.
    The ComplianceSaga receives the event and issues a command to create the ComplianceCase AR.
    (Time passes...)
    An external system approves the case, triggering a command that is handled by the ComplianceCase AR, which then publishes a ComplianceCaseApproved event.
    The ComplianceSaga receives this second event and issues a ResumePaymentCommand.
    The ResumePaymentCommandHandler re-hydrates the PaymentTransaction's State Machine and fires a RESUME event.
    The FSM transitions out of the PENDING_COMPLIANCE state and triggers the next action, which is asynchronous (sending a JMS message for the debit leg).
    The transaction proceeds to completion.

Please find the implementation specification for this design below.

Architectural Implementation Specification: V3 Hybrid Saga

1.0 Objective

Implement the V3 Hybrid Saga feature for the book-transfers-service. The implementation must adhere strictly to every rule and specification detailed in this document.

2.0 Governing Architectural Principles (Non-Negotiable)

The implementation will be governed by the following strict principles. Any deviation is considered a failure.

    2.1: The Dependency Rule: All dependencies must flow from infrastructure to core. No component within the core package shall import, reference, or otherwise depend on any component from the infrastructure package.

    2.2: Aggregate Root Invariants: Aggregate Roots are the sole guardians of their state and consistency. They MUST enforce their own internal business rules and lifecycle invariants. Logic that orchestrates processes between aggregates or involves external systems belongs in the Application Layer (Sagas, Command Handlers) or Infrastructure Layer (State Machines), not within the aggregates themselves.

    2.3: Repository Responsibility: Repository Adapters have a single responsibility: persistence and retrieval of their designated Aggregate Root. They MUST NOT contain business logic, event publication orchestration, or any other concern. They are a "dumb" persistence mechanism.

    2.4: Application Service Responsibility: Application Services (e.g., Command Handlers, Sagas) are responsible for orchestrating the unit of work. This includes coordinating calls to repositories and event publishers within a single, atomic transaction.

    2.5: Implementation Completeness: The implementation must be complete and unabridged. No placeholders, omissions, //TODO comments representing unfinished logic, or simplifications for "clarity" are permitted in the final implementation. All specified compensation paths and logic flows must be fully implemented.

3.0 Component Specification

The following components will be created or modified as specified.

3.1: Core Domain Layer (core.domain)

    3.1.1: Aggregate: Payment (Modification)

        Path: ./src/main/java/dexter/banking/booktransfers/core/domain/model/Payment.java

        Specification:

            A new public method flagForComplianceCheck() will be added.

            This method's sole responsibility is to register a PaymentRequiresComplianceCheck event. It MUST NOT contain any conditional logic regarding the aggregate's current state.

    3.1.2: Aggregate: ComplianceCase (New)

        Path: ./src/main/java/dexter/banking/booktransfers/core/domain/model/compliance/ComplianceCase.java

        Specification:

            Will be a new Aggregate Root with a UUID identifier.

            Will contain a paymentId and a Status enum (PENDING_VERIFICATION, APPROVED, REJECTED).

            A public approve() method MUST be included. This method MUST contain a guard to enforce its internal invariant: it will throw an IllegalStateException if the case's current status is not PENDING_VERIFICATION. Upon success, it will change the status to APPROVED and register a ComplianceCaseApproved event.

    3.1.3: Value Objects (New):

        core/domain/model/valueobject/RelId.java: A record wrapping a customer UUID.

        core/domain/model/valueobject/TransactionAmount.java: A record wrapping a BigDecimal amount and a Currency.

    3.1.4: Domain Events (New):

        core/domain/event/PaymentRequiresComplianceCheck.java: An event containing the Payment aggregate ID.

        core/domain/event/ComplianceCaseApproved.java: An event containing the ComplianceCase aggregate ID and the associated paymentId.

    3.1.5: Enums (Modification):

        core/domain/model/TransactionState.java: Add the state PENDING_COMPLIANCE. Remove CREDIT_LEG_FAILED and DEBIT_LEG_FAILED as they are not valid terminal states.

        core/domain/model/TransactionEvent.java: Add the events LIMIT_APPROVED, COMPLIANCE_PASSED, and RESUME.

        core/domain/model/ApiVersion.java: Add the version V3.

3.2: Core Application Layer (core.usecase, core.port)

    3.2.1: Ports (New):

        core/port/CustomerPort.java: Defines the contract boolean isCustomerValid(RelId relId).

        core/port/ComplianceCaseRepositoryPort.java: Defines the contract void save(ComplianceCase complianceCase).

        core/port/DomainEventPublisherPort.java: Defines the contract void publish(List<DomainEvent<?>> events).

        core/port/ResumableTransactionOrchestratorPort.java: An interface that extends TransactionOrchestratorPort and adds the method void resumeTransaction(UUID paymentId).

    3.2.2: Application Service: ComplianceSaga (New)

        Path: core/usecase/compliance/ComplianceSaga.java

        Specification: A stateless service that listens for domain events to orchestrate the compliance workflow. It MUST contain two public methods:

            on(PaymentRequiresComplianceCheck event): Issues a CreateComplianceCaseCommand.

            on(ComplianceCaseApproved event): Issues a ResumePaymentCommand.

            Both methods MUST be annotated with @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT) to ensure transactional consistency.

    3.2.3: Commands & Handlers (New & Modified):

        core/usecase/payment/PaymentCommand.java: Modified to include V3 fields (RelId, TransactionAmount).

        core/usecase/compliance/CreateComplianceCaseCommandHandler.java: The handle method MUST orchestrate the unit of work by first calling complianceCaseRepository.save() and then domainEventPublisher.publish().

        core/usecase/payment/ResumePaymentCommandHandler.java: MUST inject the ResumableTransactionOrchestratorPort interface using @Qualifier("hybridStatemachine").

        core/usecase/payment/SubmitPaymentV3CommandHandler.java: A new handler that matches ApiVersion.V3. It MUST inject TransactionOrchestratorPort using @Qualifier("hybridStatemachine"). It performs customer validation via CustomerPort before delegating to the orchestrator.

        core/usecase/payment/SubmitPaymentV2CommandHandler.java: The matches method will be updated to no longer be the default handler for non-V1 commands.

3.3: Infrastructure Layer (infrastructure)

    3.3.1: API Layer (New & Modified):

        infrastructure/adapter/in/web/dto/BookTransferRequestV3.java: A new DTO for the V3 API.

        infrastructure/adapter/in/web/mapper/WebMapper.java: Modified to include a toCommandV3 mapping method.

        infrastructure/adapter/in/web/BookTransferController.java: Modified to include a new POST /api/v3/book-transfers/payment endpoint.

    3.3.2: Eventing Adapter (New):

        infrastructure/adapter/out/events/SpringDomainEventPublisherAdapter.java: Implements DomainEventPublisherPort using Spring's ApplicationEventPublisher.

    3.3.3: Persistence Adapters (New & Modified):

        infrastructure/adapter/out/persistence/compliance/mongo/...: A new set of classes (MongoComplianceCaseRepository, ComplianceCaseDocument, etc.) to implement the ComplianceCaseRepositoryPort.

        infrastructure/adapter/out/orchestration/transaction/common/component/TransactionStateMachinePersister.java: The domainEventPublisher dependency and its usage MUST be removed. This component's sole responsibility is persistence.

        infrastructure/adapter/out/orchestration/transaction/statemachine/component/EventDispatchingInterceptor.java: This interceptor is now the SOLE component responsible for publishing events from the state machine flow. It MUST be injected with DomainEventPublisherPort and its postTransition method will pull events from the aggregate in the context and publish them.

    3.3.4: Orchestration Layer (New):

        infrastructure/adapter/out/orchestration/transaction/hybrid/HybridStateMachineOrchestratorAdapter.java: A new adapter with bean name "hybridStatemachine". It MUST implement ResumableTransactionOrchestratorPort.

        infrastructure/adapter/out/orchestration/transaction/hybrid/V3StateMachineConfig.java: The state machine configuration. It MUST be complete, including all success and compensation paths for the limit, debit, and credit legs, and must not contain any placeholders. The logic must be: Sync Limit Check -> Compliance Pause -> Resume -> Async Debit Leg -> Async Credit Leg -> Completion/Compensation.

        infrastructure/adapter/out/orchestration/transaction/hybrid/action/...: New Action classes for the V3 flow. ComplianceDecisionAction MUST source its decision from an external configuration property.

    3.3.5: Configuration (New & Modified):

        src/main/resources/application.yml: Add a new section service-config.v3.compliance-check-required: true.

        infrastructure/adapter/out/config/V3Config.java: A new @ConfigurationProperties class for V3-specific settings.

        infrastructure/adapter/out/config/ServiceConfigProperties.java: Modified to include the V3Config.

    3.3.6: Stub Adapter (New):

        infrastructure/adapter/out/customer/CustomerAdapterStub.java: A stub implementation for CustomerPort that always returns true.

4.0 Required Artifacts for Execution

To execute this specification, provide the following five artifacts in their entirety: blueprint.txt, bt_structure.txt, blueprint_cd.txt, cd_structure.txt, book_transfers_service_demo.postman_collection.json.

5.0 Execution Protocol

    5.1: You (the user) will provide this entire specification document as a prompt.

    5.2: I (the AI) will respond with exactly two items: 1) A single, complete amend.txt file containing all code modifications. 2) The exact shell commands required for execution.

    5.3: You will spell back your understading of the execution protocol and confirm readiness. If you're have some reservations or clarifying questions, please voice them to me.